<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.4" />
<title>jumpscale.sals.reservation_chatflow.solutions API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>jumpscale.sals.reservation_chatflow.solutions</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">from jumpscale.loader import j
from jumpscale.clients.explorer.models import NextAction, WorkloadType

K8S_SIZES = {1: {&#34;CPU&#34;: 1, &#34;Memory&#34;: 2048, &#34;Disk Size&#34;: &#34;50GiB&#34;}, 2: {&#34;CPU&#34;: 2, &#34;Memory&#34;: 4096, &#34;Disk Size&#34;: &#34;100GiB&#34;}}


class ChatflowSolutions:
    def get_node_farm(self, node_id):
        explorer = j.core.identity.me.explorer
        farm_id = explorer.nodes.get(node_id).farm_id
        return str(explorer.farms.get(farm_id))

    def list_network_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        networks = j.sals.reservation_chatflow.deployer.list_networks(next_action=next_action, sync=sync)
        if not sync and not networks:
            networks = j.sals.reservation_chatflow.deployer.list_networks(next_action=next_action, sync=False)
        result = []
        nodes = {}
        farms = {}
        if networks:
            nodes = {node.node_id: node.farm_id for node in j.sals.zos._explorer.nodes.list()}
            farms = {farm.id: farm.name for farm in j.sals.zos._explorer.farms.list()}
        for n in networks.values():
            if not n.network_workloads:
                continue
            result.append(
                {
                    &#34;Name&#34;: n.name,
                    &#34;IP Range&#34;: n.network_workloads[-1].network_iprange,
                    &#34;nodes&#34;: {
                        res.info.node_id: f&#34;{res.iprange} {farms.get(nodes.get(res.info.node_id))}&#34;
                        for res in n.network_workloads
                    },
                    &#34;wids&#34;: [res.id for res in n.network_workloads],
                }
            )
        return result

    def list_ubuntu_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_single_container_solution(&#34;ubuntu&#34;, next_action, sync)

    def list_peertube_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;peertube&#34;, next_action, sync, &#34;nginx&#34;)

    def list_discourse_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;discourse&#34;, next_action, sync, &#34;nginx&#34;)

    def list_taiga_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;taiga&#34;, next_action, sync, &#34;nginx&#34;)

    def list_flist_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_single_container_solution(&#34;flist&#34;, next_action, sync)

    def list_gitea_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;gitea&#34;, next_action, sync, &#34;nginx&#34;)

    def list_mattermost_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;mattermost&#34;, next_action, sync, &#34;nginx&#34;)

    def list_publisher_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;publisher&#34;, next_action, sync, None)

    def list_wiki_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;wiki&#34;, next_action, sync, None)

    def list_blog_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;blog&#34;, next_action, sync, None)

    def list_website_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;website&#34;, next_action, sync, None)

    def list_threebot_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;threebot&#34;, next_action, sync)

    def list_gollum_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_single_container_solution(&#34;gollum&#34;, next_action, sync)

    def list_cryptpad_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;cryptpad&#34;, next_action, sync, &#34;nginx&#34;)

    def list_minio_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Container]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = []
        container_workloads = self._list_container_workloads(&#34;minio&#34;, next_action)
        for name in container_workloads:
            primary_dict = container_workloads[name][0]
            solution_dict = {
                &#34;wids&#34;: [primary_dict[&#34;wid&#34;]] + primary_dict[&#34;vol_ids&#34;],
                &#34;Name&#34;: name,
                &#34;Network&#34;: primary_dict[&#34;network&#34;],
                &#34;Primary IPv4&#34;: primary_dict[&#34;ipv4&#34;],
                &#34;Primary IPv6&#34;: primary_dict[&#34;ipv6&#34;],
                &#34;Primary Pool&#34;: primary_dict[&#34;pool&#34;],
            }
            for key, val in primary_dict[&#34;capacity&#34;].items():
                solution_dict[f&#34;Primary {key}&#34;] = val
            if len(container_workloads[name]) == 2:
                secondary_dict = container_workloads[name][1]
                solution_dict[&#34;wids&#34;].append(secondary_dict[&#34;wid&#34;])
                solution_dict[&#34;wids&#34;] += secondary_dict[&#34;vol_ids&#34;]
                solution_dict.update(
                    {
                        &#34;Secondary IPv4&#34;: secondary_dict[&#34;ipv4&#34;],
                        &#34;Secondary IPv6&#34;: secondary_dict[&#34;ipv6&#34;],
                        &#34;Secondary Pool&#34;: secondary_dict[&#34;pool&#34;],
                    }
                )
                for key, val in secondary_dict[&#34;capacity&#34;].items():
                    solution_dict[f&#34;Secondary {key}&#34;] = val
            result.append(solution_dict)
        return result

    def list_kubernetes_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Kubernetes]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = {}
        for kube_workloads in j.sals.reservation_chatflow.deployer.workloads[next_action][
            WorkloadType.Kubernetes
        ].values():
            for workload in kube_workloads:
                if not workload.info.metadata:
                    continue
                try:
                    metadata = j.data.serializers.json.loads(workload.info.metadata)
                except:
                    continue
                if not metadata.get(&#34;form_info&#34;):
                    continue
                name = metadata[&#34;form_info&#34;].get(&#34;Solution name&#34;, metadata.get(&#34;name&#34;))
                if name:
                    if name in result:
                        if workload.master_ips:
                            result[name][&#34;wids&#34;].append(workload.id)
                            result[name][&#34;Slave IPs&#34;].append(workload.ipaddress)
                            result[name][&#34;Slave Pools&#34;].append(workload.info.pool_id)
                        continue
                    result[name] = {
                        &#34;wids&#34;: [workload.id],
                        &#34;Name&#34;: name,
                        &#34;Network&#34;: workload.network_id,
                        &#34;Master IP&#34;: workload.ipaddress if not workload.master_ips else workload.master_ips[0],
                        &#34;Slave IPs&#34;: [],
                        &#34;Slave Pools&#34;: [],
                        &#34;Master Pool&#34;: workload.info.pool_id,
                    }
                    result[name].update(self.get_workload_capacity(workload))
                    if workload.master_ips:
                        result[name][&#34;Slave IPs&#34;].append(workload.ipaddress)
        return list(result.values())

    def list_monitoring_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Container]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = []
        container_workloads = self._list_container_workloads(&#34;monitoring&#34;, next_action)
        for name in container_workloads:
            if len(container_workloads[name]) != 3:
                continue
            solution_dict = {&#34;wids&#34;: [], &#34;Name&#34;: name}
            for c_dict in container_workloads[name]:
                solution_dict[&#34;wids&#34;].append(c_dict[&#34;wid&#34;])
                solution_dict[&#34;wids&#34;] += c_dict[&#34;vol_ids&#34;]
                if &#34;grafana&#34; in c_dict[&#34;flist&#34;]:
                    cont_type = &#34;Grafana&#34;
                elif &#34;prometheus&#34; in c_dict[&#34;flist&#34;]:
                    cont_type = &#34;Prometheus&#34;
                elif &#34;redis_zinit&#34; in c_dict[&#34;flist&#34;]:
                    cont_type = &#34;Redis&#34;
                else:
                    continue
                solution_dict[f&#34;{cont_type} IPv4&#34;] = c_dict[&#34;ipv4&#34;]
                solution_dict[f&#34;{cont_type} IPv6&#34;] = c_dict[&#34;ipv6&#34;]
                solution_dict[f&#34;{cont_type} Node&#34;] = c_dict[&#34;node&#34;]
                solution_dict[f&#34;{cont_type} Farm&#34;] = self.get_node_farm(c_dict[&#34;node&#34;])
                solution_dict[f&#34;{cont_type} Pool&#34;] = c_dict[&#34;pool&#34;]
                for key, val in c_dict[&#34;capacity&#34;].items():
                    solution_dict[f&#34;{cont_type} {key}&#34;] = val
            result.append(solution_dict)
        return result

    def list_4to6gw_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Gateway4to6]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = []
        for gateways in j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Gateway4to6].values():
            for g in gateways:
                result.append(
                    {
                        &#34;wids&#34;: [g.id],
                        &#34;Name&#34;: g.public_key,
                        &#34;Public Key&#34;: g.public_key,
                        &#34;Gateway&#34;: g.info.node_id,
                        &#34;Pool&#34;: g.info.pool_id,
                    }
                )
        return result

    def list_delegated_domain_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Domain_delegate]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = []
        for domains in j.sals.reservation_chatflow.deployer.workloads[next_action][
            WorkloadType.Domain_delegate
        ].values():
            for dom in domains:
                result.append(
                    {&#34;wids&#34;: [dom.id], &#34;Name&#34;: dom.domain, &#34;Gateway&#34;: dom.info.node_id, &#34;Pool&#34;: dom.info.pool_id}
                )
        return result

    def list_exposed_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Reverse_proxy]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = {}
        pools = set()
        name_to_proxy = {}
        for proxies in j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Reverse_proxy].values():
            for proxy in proxies:
                if proxy.info.metadata:
                    metadata = j.data.serializers.json.loads(proxy.info.metadata)
                    if not metadata:
                        continue
                    chatflow = metadata.get(&#34;form_info&#34;, {}).get(&#34;chatflow&#34;)
                    if chatflow and chatflow != &#34;exposed&#34;:
                        continue
                    result[f&#34;{proxy.info.pool_id}-{proxy.domain}&#34;] = {
                        &#34;wids&#34;: [proxy.id],
                        &#34;Name&#34;: proxy.domain,
                        &#34;Gateway&#34;: proxy.info.node_id,
                        &#34;Pool&#34;: proxy.info.pool_id,
                        &#34;Domain&#34;: proxy.domain,
                    }
                    name = metadata.get(&#34;Solution name&#34;, metadata.get(&#34;form_info&#34;, {}).get(&#34;Solution name&#34;))
                    name_to_proxy[name] = f&#34;{proxy.info.pool_id}-{proxy.domain}&#34;
                pools.add(proxy.info.pool_id)

        # link subdomains to proxy_reservations
        for subdomains in j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Subdomain].values():
            for workload in subdomains:
                metadata = j.data.serializers.json.loads(workload.info.metadata)
                if not metadata:
                    continue
                chatflow = metadata.get(&#34;form_info&#34;, {}).get(&#34;chatflow&#34;)
                if chatflow and chatflow != &#34;exposed&#34;:
                    continue
                solution_name = metadata.get(
                    &#34;Solution name&#34;, metadata.get(&#34;name&#34;, metadata.get(&#34;form_info&#34;, {}).get(&#34;Solution name&#34;))
                )
                if not solution_name:
                    continue
                domain = workload.domain
                if name_to_proxy.get(solution_name):
                    result[name_to_proxy[solution_name]][&#34;wids&#34;].append(workload.id)

        # link tcp router containers to proxy reservations
        for pool_id in pools:
            for container_workload in j.sals.reservation_chatflow.deployer.workloads[next_action][
                WorkloadType.Container
            ][pool_id]:
                if (
                    container_workload.flist != &#34;https://hub.grid.tf/tf-official-apps/tcprouter:latest.flist&#34;
                    or not container_workload.info.metadata
                ):
                    continue
                metadata = j.data.serializers.json.loads(container_workload.info.metadata)
                if not metadata:
                    continue
                chatflow = metadata.get(&#34;form_info&#34;, {}).get(&#34;chatflow&#34;)
                if chatflow and chatflow != &#34;exposed&#34;:
                    continue
                solution_name = metadata.get(
                    &#34;Solution name&#34;, metadata.get(&#34;name&#34;, metadata.get(&#34;form_info&#34;, {}).get(&#34;Solution name&#34;))
                )
                if not solution_name:
                    continue
                if name_to_proxy.get(solution_name):
                    domain = name_to_proxy.get(solution_name)
                    result[domain][&#34;wids&#34;].append(container_workload.id)
        return list(result.values())

    def cancel_solution(self, solution_wids):
        &#34;&#34;&#34;
        solution_wids should be part of the same solution. if they are not created by the same solution they may not all be deleted
        &#34;&#34;&#34;
        workload = j.sals.zos.workloads.get(solution_wids[0])
        solution_uuid = self.get_solution_uuid(workload)
        ids_to_delete = []
        if solution_uuid:
            # solutions created by new chatflows
            for workload in j.sals.zos.workloads.list(j.core.identity.me.tid, next_action=&#34;DEPLOY&#34;):
                if solution_uuid == self.get_solution_uuid(workload):
                    ids_to_delete.append(workload.id)
        else:
            ids_to_delete = solution_wids

        for wid in ids_to_delete:
            j.sals.zos.workloads.decomission(wid)

    def count_solutions(self, next_action=NextAction.DEPLOY):
        count_dict = {
            &#34;network&#34;: 0,
            &#34;ubuntu&#34;: 0,
            &#34;kubernetes&#34;: 0,
            &#34;minio&#34;: 0,
            &#34;monitoring&#34;: 0,
            &#34;flist&#34;: 0,
            &#34;gitea&#34;: 0,
            &#34;4to6gw&#34;: 0,
            &#34;delegated_domain&#34;: 0,
            &#34;exposed&#34;: 0,
            &#34;threebot&#34;: 0,
            &#34;peertube&#34;: 0,
            &#34;discourse&#34;: 0,
            &#34;gollum&#34;: 0,
            &#34;mattermost&#34;: 0,
            &#34;peertube&#34;: 0,
            &#34;cryptpad&#34;: 0,
            &#34;publisher&#34;: 0,
            &#34;wiki&#34;: 0,
            &#34;blog&#34;: 0,
            &#34;website&#34;: 0,
            &#34;taiga&#34;: 0,
        }
        j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        for key in count_dict.keys():
            method = getattr(self, f&#34;list_{key}_solutions&#34;)
            count_dict[key] = len(method(next_action=next_action, sync=False))
        return count_dict

    def get_solution_uuid(self, workload):
        if workload.info.metadata:
            try:
                metadata = j.data.serializers.json.loads(
                    j.sals.reservation_chatflow.deployer.decrypt_metadata(workload.info.metadata)
                )
            except:
                return
            if metadata:
                solution_uuid = metadata.get(&#34;solution_uuid&#34;)
                return solution_uuid

    def get_ipv6_address(self, workload):
        result = j.data.serializers.json.loads(workload.info.result.data_json)
        if not result:
            result = {}
        return result.get(&#34;ipv6&#34;)

    def get_workload_capacity(self, workload):
        result = {}
        if workload.info.workload_type == WorkloadType.Container:
            result[&#34;CPU&#34;] = workload.capacity.cpu
            result[&#34;Memory&#34;] = workload.capacity.memory
            result[&#34;RootFS Type&#34;] = workload.capacity.disk_type.name
            result[&#34;RootFS Size&#34;] = workload.capacity.disk_size
        elif workload.info.workload_type == WorkloadType.Kubernetes:
            result.update(K8S_SIZES.get(workload.size, {}))
        elif workload.info.workload_type == WorkloadType.Volume:
            result[&#34;Size&#34;] = workload.size * 1024
            result[&#34;Type&#34;] = workload.type.name
        return result

    def _validate_workload_metadata(self, chatflow, workload):
        if not workload.info.metadata:
            return
        try:
            metadata = j.data.serializers.json.loads(workload.info.metadata)
        except:
            return

        if not metadata.get(&#34;form_info&#34;):
            return
        if metadata[&#34;form_info&#34;].get(&#34;chatflow&#34;) != chatflow:
            return

        return metadata

    def _list_container_workloads(
        self,
        chatflow,
        next_action=NextAction.DEPLOY,
        name_identitfier=lambda metadata: metadata.get(&#34;name&#34;, metadata[&#34;form_info&#34;].get(&#34;Solution name&#34;)),
        metadata_filters=None,
    ):
        &#34;&#34;&#34;
        Args:
            chatflow: chatflow value set in metadata
            next_action: workload next action
            name_identifier: function with one parameter metadata and returns the solution name
            metadata_filters: list of methods with one parameter metadata and returns True/False. if return is False the workload will be filtered

        Returns:
            {&#34;name&#34;: [container_dict]}  # container_dict keys: flist, ipv4, ipv6, capacity, wid, vol_ids, node, pool
        &#34;&#34;&#34;
        metadata_filters = metadata_filters or []
        result = {}
        values = j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Container].values()
        for container_workloads in values:
            for workload in container_workloads:
                metadata = self._validate_workload_metadata(chatflow, workload)
                if not metadata:
                    continue
                valid = True
                for meta_filter in metadata_filters:
                    if not meta_filter(metadata):
                        valid = False
                        break
                if not valid:
                    continue

                name = name_identitfier(metadata)
                container_dict = {
                    &#34;wid&#34;: workload.id,
                    &#34;flist&#34;: workload.flist,
                    &#34;ipv4&#34;: workload.network_connection[0].ipaddress,
                    &#34;ipv6&#34;: self.get_ipv6_address(workload),
                    &#34;network&#34;: workload.network_connection[0].network_id,
                    &#34;node&#34;: workload.info.node_id,
                    &#34;farm&#34;: self.get_node_farm(workload.info.node_id),
                    &#34;pool&#34;: workload.info.pool_id,
                    &#34;vol_ids&#34;: [],
                    &#34;capacity&#34;: self.get_workload_capacity(workload),
                    &#34;owner&#34;: metadata.get(&#34;owner&#34;),
                }
                if workload.volumes:
                    for vol in workload.volumes:
                        container_dict[&#34;vol_ids&#34;].append(int(vol.volume_id.split(&#34;-&#34;)[0]))
                if name not in result:
                    result[name] = [container_dict]
                else:
                    result[name].append(container_dict)
        return result

    def _list_subdomain_workloads(
        self,
        chatflow,
        next_action=NextAction.DEPLOY,
        name_identitfier=lambda metadata: metadata.get(&#34;name&#34;, metadata[&#34;form_info&#34;].get(&#34;Solution name&#34;)),
        metadata_filters=None,
    ):
        &#34;&#34;&#34;
        Args:
            chatflow: chatflow value set in metadata
            next_action: workload next action
            name_identifier: function with one parameter metadata and returns the solution name
            metadata_filters: list of methods with one parameter metadata and returns True/False. if return is False the workload will be filtered

        Returns:
            {&#34;name&#34;: [subdomain_dict]}  # subdomain_dict keys: wid, domain, ips
        &#34;&#34;&#34;
        metadata_filters = metadata_filters or []
        result = {}
        values = j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Subdomain].values()
        for subdomain_workloads in values:
            for workload in subdomain_workloads:
                metadata = self._validate_workload_metadata(chatflow, workload)
                if not metadata:
                    continue

                valid = True
                for meta_filter in metadata_filters:
                    if not meta_filter(metadata):
                        valid = False
                        break
                if not valid:
                    continue

                name = name_identitfier(metadata)
                subdomain_dict = {
                    &#34;wid&#34;: workload.id,
                    &#34;domain&#34;: workload.domain,
                    &#34;ips&#34;: workload.ips,
                    &#34;owner&#34;: metadata.get(&#34;owner&#34;),
                }
                if name not in result:
                    result[name] = [subdomain_dict]
                else:
                    result[name].append(subdomain_dict)
        return result

    def _list_proxy_workloads(
        self,
        chatflow,
        next_action=NextAction.DEPLOY,
        name_identitfier=lambda metadata: metadata.get(&#34;name&#34;, metadata[&#34;form_info&#34;].get(&#34;Solution name&#34;)),
        metadata_filters=None,
    ):
        &#34;&#34;&#34;
        Args:
            chatflow: chatflow value set in metadata
            next_action: workload next action
            name_identifier: function with one parameter metadata and returns the solution name
            metadata_filters: list of methods with one parameter metadata and returns True/False. if return is False the workload will be filtered

        Returns:
            {&#34;name&#34;: [proxy_dict]}  # subdomain_dict keys: wid, domain
        &#34;&#34;&#34;
        result = {}
        metadata_filters = metadata_filters or []
        values = j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Reverse_proxy].values()
        for proxy_workloads in values:
            for workload in proxy_workloads:
                metadata = self._validate_workload_metadata(chatflow, workload)
                if not metadata:
                    continue

                valid = True
                for meta_filter in metadata_filters:
                    if not meta_filter(metadata):
                        valid = False
                        break
                if not valid:
                    continue

                name = name_identitfier(metadata)
                proxy_dict = {&#34;wid&#34;: workload.id, &#34;domain&#34;: workload.domain, &#34;owner&#34;: metadata.get(&#34;owner&#34;)}
                if name not in result:
                    result[name] = [proxy_dict]
                else:
                    result[name].append(proxy_dict)
        return result

    def _list_proxied_solution(
        self, chatflow, next_action=NextAction.DEPLOY, sync=True, proxy_type=&#34;tcprouter&#34;, owner=None
    ):
        def meta_filter(metadata):
            if metadata.get(&#34;owner&#34;) != owner:
                return False
            return True

        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Container]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = []
        if not proxy_type:
            containers_len = 1
        else:
            containers_len = 2
        if owner:
            container_workloads = self._list_container_workloads(chatflow, next_action, metadata_filters=[meta_filter])
            subdomain_workloads = self._list_subdomain_workloads(chatflow, next_action, metadata_filters=[meta_filter])
            proxy_workloads = self._list_proxy_workloads(chatflow, next_action, metadata_filters=[meta_filter])
        else:
            container_workloads = self._list_container_workloads(chatflow, next_action)
            subdomain_workloads = self._list_subdomain_workloads(chatflow, next_action)
            proxy_workloads = self._list_proxy_workloads(chatflow, next_action)
        for name in container_workloads:
            subdomain_dicts = subdomain_workloads.get(name)
            proxy_dicts = proxy_workloads.get(name)
            if not subdomain_dicts or not proxy_dicts:
                continue
            subdomain_dict = subdomain_dicts[0]
            proxy_dict = proxy_dicts[0]
            sol_name = name
            if owner:
                if len(name) &gt; len(owner) + 1:
                    sol_name = name[len(owner) + 1 :]
            solution_dict = {
                &#34;wids&#34;: [subdomain_dict[&#34;wid&#34;], proxy_dict[&#34;wid&#34;]],
                &#34;Name&#34;: sol_name,
                &#34;Domain&#34;: subdomain_dict[&#34;domain&#34;],
            }
            if len(container_workloads[name]) != containers_len:
                continue
            for c_dict in container_workloads[name]:
                solution_dict[&#34;wids&#34;].append(c_dict[&#34;wid&#34;])
                if (proxy_type and proxy_type not in c_dict[&#34;flist&#34;]) or not proxy_type:
                    pool = j.sals.zos.pools.get(c_dict[&#34;pool&#34;])
                    solution_dict.update(
                        {
                            &#34;IPv4 Address&#34;: c_dict[&#34;ipv4&#34;],
                            &#34;IPv6 Address&#34;: c_dict[&#34;ipv6&#34;],
                            &#34;Node&#34;: c_dict[&#34;node&#34;],
                            &#34;Farm&#34;: self.get_node_farm(c_dict[&#34;node&#34;]),
                            &#34;Pool&#34;: c_dict[&#34;pool&#34;],
                            &#34;Network&#34;: c_dict[&#34;network&#34;],
                            &#34;Expiration&#34;: pool.empty_at,
                        }
                    )
                    solution_dict.update(c_dict[&#34;capacity&#34;])
            result.append(solution_dict)
        return result

    def _list_single_container_solution(self, chatflow, next_action=NextAction.DEPLOY, sync=True, owner=None):
        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Container]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = []
        if owner:
            meta_filter = lambda metadata: False if metadata.get(&#34;owner&#34;) != owner else True
            container_workloads = self._list_container_workloads(chatflow, next_action, metadata_filters=[meta_filter])
        else:
            container_workloads = self._list_container_workloads(chatflow, next_action)
        for name in container_workloads:
            c_dict = container_workloads[name][0]
            sol_name = name
            if owner:
                if len(name) &gt; len(owner) + 1:
                    sol_name = name[len(owner) + 1 :]
            result.append(
                {
                    &#34;wids&#34;: [c_dict[&#34;wid&#34;]],
                    &#34;Name&#34;: sol_name,
                    &#34;IPv4 Address&#34;: c_dict[&#34;ipv4&#34;],
                    &#34;IPv6 Address&#34;: c_dict[&#34;ipv6&#34;],
                    &#34;Node&#34;: c_dict[&#34;node&#34;],
                    &#34;Farm&#34;: self.get_node_farm(c_dict[&#34;node&#34;]),
                    &#34;Pool&#34;: c_dict[&#34;pool&#34;],
                    &#34;Network&#34;: c_dict[&#34;network&#34;],
                }
            )
            result[-1].update(c_dict[&#34;capacity&#34;])
        return result


solutions = ChatflowSolutions()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions"><code class="flex name class">
<span>class <span class="ident">ChatflowSolutions</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class ChatflowSolutions:
    def get_node_farm(self, node_id):
        explorer = j.core.identity.me.explorer
        farm_id = explorer.nodes.get(node_id).farm_id
        return str(explorer.farms.get(farm_id))

    def list_network_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        networks = j.sals.reservation_chatflow.deployer.list_networks(next_action=next_action, sync=sync)
        if not sync and not networks:
            networks = j.sals.reservation_chatflow.deployer.list_networks(next_action=next_action, sync=False)
        result = []
        nodes = {}
        farms = {}
        if networks:
            nodes = {node.node_id: node.farm_id for node in j.sals.zos._explorer.nodes.list()}
            farms = {farm.id: farm.name for farm in j.sals.zos._explorer.farms.list()}
        for n in networks.values():
            if not n.network_workloads:
                continue
            result.append(
                {
                    &#34;Name&#34;: n.name,
                    &#34;IP Range&#34;: n.network_workloads[-1].network_iprange,
                    &#34;nodes&#34;: {
                        res.info.node_id: f&#34;{res.iprange} {farms.get(nodes.get(res.info.node_id))}&#34;
                        for res in n.network_workloads
                    },
                    &#34;wids&#34;: [res.id for res in n.network_workloads],
                }
            )
        return result

    def list_ubuntu_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_single_container_solution(&#34;ubuntu&#34;, next_action, sync)

    def list_peertube_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;peertube&#34;, next_action, sync, &#34;nginx&#34;)

    def list_discourse_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;discourse&#34;, next_action, sync, &#34;nginx&#34;)

    def list_taiga_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;taiga&#34;, next_action, sync, &#34;nginx&#34;)

    def list_flist_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_single_container_solution(&#34;flist&#34;, next_action, sync)

    def list_gitea_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;gitea&#34;, next_action, sync, &#34;nginx&#34;)

    def list_mattermost_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;mattermost&#34;, next_action, sync, &#34;nginx&#34;)

    def list_publisher_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;publisher&#34;, next_action, sync, None)

    def list_wiki_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;wiki&#34;, next_action, sync, None)

    def list_blog_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;blog&#34;, next_action, sync, None)

    def list_website_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;website&#34;, next_action, sync, None)

    def list_threebot_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;threebot&#34;, next_action, sync)

    def list_gollum_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_single_container_solution(&#34;gollum&#34;, next_action, sync)

    def list_cryptpad_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        return self._list_proxied_solution(&#34;cryptpad&#34;, next_action, sync, &#34;nginx&#34;)

    def list_minio_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Container]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = []
        container_workloads = self._list_container_workloads(&#34;minio&#34;, next_action)
        for name in container_workloads:
            primary_dict = container_workloads[name][0]
            solution_dict = {
                &#34;wids&#34;: [primary_dict[&#34;wid&#34;]] + primary_dict[&#34;vol_ids&#34;],
                &#34;Name&#34;: name,
                &#34;Network&#34;: primary_dict[&#34;network&#34;],
                &#34;Primary IPv4&#34;: primary_dict[&#34;ipv4&#34;],
                &#34;Primary IPv6&#34;: primary_dict[&#34;ipv6&#34;],
                &#34;Primary Pool&#34;: primary_dict[&#34;pool&#34;],
            }
            for key, val in primary_dict[&#34;capacity&#34;].items():
                solution_dict[f&#34;Primary {key}&#34;] = val
            if len(container_workloads[name]) == 2:
                secondary_dict = container_workloads[name][1]
                solution_dict[&#34;wids&#34;].append(secondary_dict[&#34;wid&#34;])
                solution_dict[&#34;wids&#34;] += secondary_dict[&#34;vol_ids&#34;]
                solution_dict.update(
                    {
                        &#34;Secondary IPv4&#34;: secondary_dict[&#34;ipv4&#34;],
                        &#34;Secondary IPv6&#34;: secondary_dict[&#34;ipv6&#34;],
                        &#34;Secondary Pool&#34;: secondary_dict[&#34;pool&#34;],
                    }
                )
                for key, val in secondary_dict[&#34;capacity&#34;].items():
                    solution_dict[f&#34;Secondary {key}&#34;] = val
            result.append(solution_dict)
        return result

    def list_kubernetes_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Kubernetes]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = {}
        for kube_workloads in j.sals.reservation_chatflow.deployer.workloads[next_action][
            WorkloadType.Kubernetes
        ].values():
            for workload in kube_workloads:
                if not workload.info.metadata:
                    continue
                try:
                    metadata = j.data.serializers.json.loads(workload.info.metadata)
                except:
                    continue
                if not metadata.get(&#34;form_info&#34;):
                    continue
                name = metadata[&#34;form_info&#34;].get(&#34;Solution name&#34;, metadata.get(&#34;name&#34;))
                if name:
                    if name in result:
                        if workload.master_ips:
                            result[name][&#34;wids&#34;].append(workload.id)
                            result[name][&#34;Slave IPs&#34;].append(workload.ipaddress)
                            result[name][&#34;Slave Pools&#34;].append(workload.info.pool_id)
                        continue
                    result[name] = {
                        &#34;wids&#34;: [workload.id],
                        &#34;Name&#34;: name,
                        &#34;Network&#34;: workload.network_id,
                        &#34;Master IP&#34;: workload.ipaddress if not workload.master_ips else workload.master_ips[0],
                        &#34;Slave IPs&#34;: [],
                        &#34;Slave Pools&#34;: [],
                        &#34;Master Pool&#34;: workload.info.pool_id,
                    }
                    result[name].update(self.get_workload_capacity(workload))
                    if workload.master_ips:
                        result[name][&#34;Slave IPs&#34;].append(workload.ipaddress)
        return list(result.values())

    def list_monitoring_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Container]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = []
        container_workloads = self._list_container_workloads(&#34;monitoring&#34;, next_action)
        for name in container_workloads:
            if len(container_workloads[name]) != 3:
                continue
            solution_dict = {&#34;wids&#34;: [], &#34;Name&#34;: name}
            for c_dict in container_workloads[name]:
                solution_dict[&#34;wids&#34;].append(c_dict[&#34;wid&#34;])
                solution_dict[&#34;wids&#34;] += c_dict[&#34;vol_ids&#34;]
                if &#34;grafana&#34; in c_dict[&#34;flist&#34;]:
                    cont_type = &#34;Grafana&#34;
                elif &#34;prometheus&#34; in c_dict[&#34;flist&#34;]:
                    cont_type = &#34;Prometheus&#34;
                elif &#34;redis_zinit&#34; in c_dict[&#34;flist&#34;]:
                    cont_type = &#34;Redis&#34;
                else:
                    continue
                solution_dict[f&#34;{cont_type} IPv4&#34;] = c_dict[&#34;ipv4&#34;]
                solution_dict[f&#34;{cont_type} IPv6&#34;] = c_dict[&#34;ipv6&#34;]
                solution_dict[f&#34;{cont_type} Node&#34;] = c_dict[&#34;node&#34;]
                solution_dict[f&#34;{cont_type} Farm&#34;] = self.get_node_farm(c_dict[&#34;node&#34;])
                solution_dict[f&#34;{cont_type} Pool&#34;] = c_dict[&#34;pool&#34;]
                for key, val in c_dict[&#34;capacity&#34;].items():
                    solution_dict[f&#34;{cont_type} {key}&#34;] = val
            result.append(solution_dict)
        return result

    def list_4to6gw_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Gateway4to6]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = []
        for gateways in j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Gateway4to6].values():
            for g in gateways:
                result.append(
                    {
                        &#34;wids&#34;: [g.id],
                        &#34;Name&#34;: g.public_key,
                        &#34;Public Key&#34;: g.public_key,
                        &#34;Gateway&#34;: g.info.node_id,
                        &#34;Pool&#34;: g.info.pool_id,
                    }
                )
        return result

    def list_delegated_domain_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Domain_delegate]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = []
        for domains in j.sals.reservation_chatflow.deployer.workloads[next_action][
            WorkloadType.Domain_delegate
        ].values():
            for dom in domains:
                result.append(
                    {&#34;wids&#34;: [dom.id], &#34;Name&#34;: dom.domain, &#34;Gateway&#34;: dom.info.node_id, &#34;Pool&#34;: dom.info.pool_id}
                )
        return result

    def list_exposed_solutions(self, next_action=NextAction.DEPLOY, sync=True):
        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Reverse_proxy]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = {}
        pools = set()
        name_to_proxy = {}
        for proxies in j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Reverse_proxy].values():
            for proxy in proxies:
                if proxy.info.metadata:
                    metadata = j.data.serializers.json.loads(proxy.info.metadata)
                    if not metadata:
                        continue
                    chatflow = metadata.get(&#34;form_info&#34;, {}).get(&#34;chatflow&#34;)
                    if chatflow and chatflow != &#34;exposed&#34;:
                        continue
                    result[f&#34;{proxy.info.pool_id}-{proxy.domain}&#34;] = {
                        &#34;wids&#34;: [proxy.id],
                        &#34;Name&#34;: proxy.domain,
                        &#34;Gateway&#34;: proxy.info.node_id,
                        &#34;Pool&#34;: proxy.info.pool_id,
                        &#34;Domain&#34;: proxy.domain,
                    }
                    name = metadata.get(&#34;Solution name&#34;, metadata.get(&#34;form_info&#34;, {}).get(&#34;Solution name&#34;))
                    name_to_proxy[name] = f&#34;{proxy.info.pool_id}-{proxy.domain}&#34;
                pools.add(proxy.info.pool_id)

        # link subdomains to proxy_reservations
        for subdomains in j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Subdomain].values():
            for workload in subdomains:
                metadata = j.data.serializers.json.loads(workload.info.metadata)
                if not metadata:
                    continue
                chatflow = metadata.get(&#34;form_info&#34;, {}).get(&#34;chatflow&#34;)
                if chatflow and chatflow != &#34;exposed&#34;:
                    continue
                solution_name = metadata.get(
                    &#34;Solution name&#34;, metadata.get(&#34;name&#34;, metadata.get(&#34;form_info&#34;, {}).get(&#34;Solution name&#34;))
                )
                if not solution_name:
                    continue
                domain = workload.domain
                if name_to_proxy.get(solution_name):
                    result[name_to_proxy[solution_name]][&#34;wids&#34;].append(workload.id)

        # link tcp router containers to proxy reservations
        for pool_id in pools:
            for container_workload in j.sals.reservation_chatflow.deployer.workloads[next_action][
                WorkloadType.Container
            ][pool_id]:
                if (
                    container_workload.flist != &#34;https://hub.grid.tf/tf-official-apps/tcprouter:latest.flist&#34;
                    or not container_workload.info.metadata
                ):
                    continue
                metadata = j.data.serializers.json.loads(container_workload.info.metadata)
                if not metadata:
                    continue
                chatflow = metadata.get(&#34;form_info&#34;, {}).get(&#34;chatflow&#34;)
                if chatflow and chatflow != &#34;exposed&#34;:
                    continue
                solution_name = metadata.get(
                    &#34;Solution name&#34;, metadata.get(&#34;name&#34;, metadata.get(&#34;form_info&#34;, {}).get(&#34;Solution name&#34;))
                )
                if not solution_name:
                    continue
                if name_to_proxy.get(solution_name):
                    domain = name_to_proxy.get(solution_name)
                    result[domain][&#34;wids&#34;].append(container_workload.id)
        return list(result.values())

    def cancel_solution(self, solution_wids):
        &#34;&#34;&#34;
        solution_wids should be part of the same solution. if they are not created by the same solution they may not all be deleted
        &#34;&#34;&#34;
        workload = j.sals.zos.workloads.get(solution_wids[0])
        solution_uuid = self.get_solution_uuid(workload)
        ids_to_delete = []
        if solution_uuid:
            # solutions created by new chatflows
            for workload in j.sals.zos.workloads.list(j.core.identity.me.tid, next_action=&#34;DEPLOY&#34;):
                if solution_uuid == self.get_solution_uuid(workload):
                    ids_to_delete.append(workload.id)
        else:
            ids_to_delete = solution_wids

        for wid in ids_to_delete:
            j.sals.zos.workloads.decomission(wid)

    def count_solutions(self, next_action=NextAction.DEPLOY):
        count_dict = {
            &#34;network&#34;: 0,
            &#34;ubuntu&#34;: 0,
            &#34;kubernetes&#34;: 0,
            &#34;minio&#34;: 0,
            &#34;monitoring&#34;: 0,
            &#34;flist&#34;: 0,
            &#34;gitea&#34;: 0,
            &#34;4to6gw&#34;: 0,
            &#34;delegated_domain&#34;: 0,
            &#34;exposed&#34;: 0,
            &#34;threebot&#34;: 0,
            &#34;peertube&#34;: 0,
            &#34;discourse&#34;: 0,
            &#34;gollum&#34;: 0,
            &#34;mattermost&#34;: 0,
            &#34;peertube&#34;: 0,
            &#34;cryptpad&#34;: 0,
            &#34;publisher&#34;: 0,
            &#34;wiki&#34;: 0,
            &#34;blog&#34;: 0,
            &#34;website&#34;: 0,
            &#34;taiga&#34;: 0,
        }
        j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        for key in count_dict.keys():
            method = getattr(self, f&#34;list_{key}_solutions&#34;)
            count_dict[key] = len(method(next_action=next_action, sync=False))
        return count_dict

    def get_solution_uuid(self, workload):
        if workload.info.metadata:
            try:
                metadata = j.data.serializers.json.loads(
                    j.sals.reservation_chatflow.deployer.decrypt_metadata(workload.info.metadata)
                )
            except:
                return
            if metadata:
                solution_uuid = metadata.get(&#34;solution_uuid&#34;)
                return solution_uuid

    def get_ipv6_address(self, workload):
        result = j.data.serializers.json.loads(workload.info.result.data_json)
        if not result:
            result = {}
        return result.get(&#34;ipv6&#34;)

    def get_workload_capacity(self, workload):
        result = {}
        if workload.info.workload_type == WorkloadType.Container:
            result[&#34;CPU&#34;] = workload.capacity.cpu
            result[&#34;Memory&#34;] = workload.capacity.memory
            result[&#34;RootFS Type&#34;] = workload.capacity.disk_type.name
            result[&#34;RootFS Size&#34;] = workload.capacity.disk_size
        elif workload.info.workload_type == WorkloadType.Kubernetes:
            result.update(K8S_SIZES.get(workload.size, {}))
        elif workload.info.workload_type == WorkloadType.Volume:
            result[&#34;Size&#34;] = workload.size * 1024
            result[&#34;Type&#34;] = workload.type.name
        return result

    def _validate_workload_metadata(self, chatflow, workload):
        if not workload.info.metadata:
            return
        try:
            metadata = j.data.serializers.json.loads(workload.info.metadata)
        except:
            return

        if not metadata.get(&#34;form_info&#34;):
            return
        if metadata[&#34;form_info&#34;].get(&#34;chatflow&#34;) != chatflow:
            return

        return metadata

    def _list_container_workloads(
        self,
        chatflow,
        next_action=NextAction.DEPLOY,
        name_identitfier=lambda metadata: metadata.get(&#34;name&#34;, metadata[&#34;form_info&#34;].get(&#34;Solution name&#34;)),
        metadata_filters=None,
    ):
        &#34;&#34;&#34;
        Args:
            chatflow: chatflow value set in metadata
            next_action: workload next action
            name_identifier: function with one parameter metadata and returns the solution name
            metadata_filters: list of methods with one parameter metadata and returns True/False. if return is False the workload will be filtered

        Returns:
            {&#34;name&#34;: [container_dict]}  # container_dict keys: flist, ipv4, ipv6, capacity, wid, vol_ids, node, pool
        &#34;&#34;&#34;
        metadata_filters = metadata_filters or []
        result = {}
        values = j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Container].values()
        for container_workloads in values:
            for workload in container_workloads:
                metadata = self._validate_workload_metadata(chatflow, workload)
                if not metadata:
                    continue
                valid = True
                for meta_filter in metadata_filters:
                    if not meta_filter(metadata):
                        valid = False
                        break
                if not valid:
                    continue

                name = name_identitfier(metadata)
                container_dict = {
                    &#34;wid&#34;: workload.id,
                    &#34;flist&#34;: workload.flist,
                    &#34;ipv4&#34;: workload.network_connection[0].ipaddress,
                    &#34;ipv6&#34;: self.get_ipv6_address(workload),
                    &#34;network&#34;: workload.network_connection[0].network_id,
                    &#34;node&#34;: workload.info.node_id,
                    &#34;farm&#34;: self.get_node_farm(workload.info.node_id),
                    &#34;pool&#34;: workload.info.pool_id,
                    &#34;vol_ids&#34;: [],
                    &#34;capacity&#34;: self.get_workload_capacity(workload),
                    &#34;owner&#34;: metadata.get(&#34;owner&#34;),
                }
                if workload.volumes:
                    for vol in workload.volumes:
                        container_dict[&#34;vol_ids&#34;].append(int(vol.volume_id.split(&#34;-&#34;)[0]))
                if name not in result:
                    result[name] = [container_dict]
                else:
                    result[name].append(container_dict)
        return result

    def _list_subdomain_workloads(
        self,
        chatflow,
        next_action=NextAction.DEPLOY,
        name_identitfier=lambda metadata: metadata.get(&#34;name&#34;, metadata[&#34;form_info&#34;].get(&#34;Solution name&#34;)),
        metadata_filters=None,
    ):
        &#34;&#34;&#34;
        Args:
            chatflow: chatflow value set in metadata
            next_action: workload next action
            name_identifier: function with one parameter metadata and returns the solution name
            metadata_filters: list of methods with one parameter metadata and returns True/False. if return is False the workload will be filtered

        Returns:
            {&#34;name&#34;: [subdomain_dict]}  # subdomain_dict keys: wid, domain, ips
        &#34;&#34;&#34;
        metadata_filters = metadata_filters or []
        result = {}
        values = j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Subdomain].values()
        for subdomain_workloads in values:
            for workload in subdomain_workloads:
                metadata = self._validate_workload_metadata(chatflow, workload)
                if not metadata:
                    continue

                valid = True
                for meta_filter in metadata_filters:
                    if not meta_filter(metadata):
                        valid = False
                        break
                if not valid:
                    continue

                name = name_identitfier(metadata)
                subdomain_dict = {
                    &#34;wid&#34;: workload.id,
                    &#34;domain&#34;: workload.domain,
                    &#34;ips&#34;: workload.ips,
                    &#34;owner&#34;: metadata.get(&#34;owner&#34;),
                }
                if name not in result:
                    result[name] = [subdomain_dict]
                else:
                    result[name].append(subdomain_dict)
        return result

    def _list_proxy_workloads(
        self,
        chatflow,
        next_action=NextAction.DEPLOY,
        name_identitfier=lambda metadata: metadata.get(&#34;name&#34;, metadata[&#34;form_info&#34;].get(&#34;Solution name&#34;)),
        metadata_filters=None,
    ):
        &#34;&#34;&#34;
        Args:
            chatflow: chatflow value set in metadata
            next_action: workload next action
            name_identifier: function with one parameter metadata and returns the solution name
            metadata_filters: list of methods with one parameter metadata and returns True/False. if return is False the workload will be filtered

        Returns:
            {&#34;name&#34;: [proxy_dict]}  # subdomain_dict keys: wid, domain
        &#34;&#34;&#34;
        result = {}
        metadata_filters = metadata_filters or []
        values = j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Reverse_proxy].values()
        for proxy_workloads in values:
            for workload in proxy_workloads:
                metadata = self._validate_workload_metadata(chatflow, workload)
                if not metadata:
                    continue

                valid = True
                for meta_filter in metadata_filters:
                    if not meta_filter(metadata):
                        valid = False
                        break
                if not valid:
                    continue

                name = name_identitfier(metadata)
                proxy_dict = {&#34;wid&#34;: workload.id, &#34;domain&#34;: workload.domain, &#34;owner&#34;: metadata.get(&#34;owner&#34;)}
                if name not in result:
                    result[name] = [proxy_dict]
                else:
                    result[name].append(proxy_dict)
        return result

    def _list_proxied_solution(
        self, chatflow, next_action=NextAction.DEPLOY, sync=True, proxy_type=&#34;tcprouter&#34;, owner=None
    ):
        def meta_filter(metadata):
            if metadata.get(&#34;owner&#34;) != owner:
                return False
            return True

        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Container]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = []
        if not proxy_type:
            containers_len = 1
        else:
            containers_len = 2
        if owner:
            container_workloads = self._list_container_workloads(chatflow, next_action, metadata_filters=[meta_filter])
            subdomain_workloads = self._list_subdomain_workloads(chatflow, next_action, metadata_filters=[meta_filter])
            proxy_workloads = self._list_proxy_workloads(chatflow, next_action, metadata_filters=[meta_filter])
        else:
            container_workloads = self._list_container_workloads(chatflow, next_action)
            subdomain_workloads = self._list_subdomain_workloads(chatflow, next_action)
            proxy_workloads = self._list_proxy_workloads(chatflow, next_action)
        for name in container_workloads:
            subdomain_dicts = subdomain_workloads.get(name)
            proxy_dicts = proxy_workloads.get(name)
            if not subdomain_dicts or not proxy_dicts:
                continue
            subdomain_dict = subdomain_dicts[0]
            proxy_dict = proxy_dicts[0]
            sol_name = name
            if owner:
                if len(name) &gt; len(owner) + 1:
                    sol_name = name[len(owner) + 1 :]
            solution_dict = {
                &#34;wids&#34;: [subdomain_dict[&#34;wid&#34;], proxy_dict[&#34;wid&#34;]],
                &#34;Name&#34;: sol_name,
                &#34;Domain&#34;: subdomain_dict[&#34;domain&#34;],
            }
            if len(container_workloads[name]) != containers_len:
                continue
            for c_dict in container_workloads[name]:
                solution_dict[&#34;wids&#34;].append(c_dict[&#34;wid&#34;])
                if (proxy_type and proxy_type not in c_dict[&#34;flist&#34;]) or not proxy_type:
                    pool = j.sals.zos.pools.get(c_dict[&#34;pool&#34;])
                    solution_dict.update(
                        {
                            &#34;IPv4 Address&#34;: c_dict[&#34;ipv4&#34;],
                            &#34;IPv6 Address&#34;: c_dict[&#34;ipv6&#34;],
                            &#34;Node&#34;: c_dict[&#34;node&#34;],
                            &#34;Farm&#34;: self.get_node_farm(c_dict[&#34;node&#34;]),
                            &#34;Pool&#34;: c_dict[&#34;pool&#34;],
                            &#34;Network&#34;: c_dict[&#34;network&#34;],
                            &#34;Expiration&#34;: pool.empty_at,
                        }
                    )
                    solution_dict.update(c_dict[&#34;capacity&#34;])
            result.append(solution_dict)
        return result

    def _list_single_container_solution(self, chatflow, next_action=NextAction.DEPLOY, sync=True, owner=None):
        if sync:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Container]:
            j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
        result = []
        if owner:
            meta_filter = lambda metadata: False if metadata.get(&#34;owner&#34;) != owner else True
            container_workloads = self._list_container_workloads(chatflow, next_action, metadata_filters=[meta_filter])
        else:
            container_workloads = self._list_container_workloads(chatflow, next_action)
        for name in container_workloads:
            c_dict = container_workloads[name][0]
            sol_name = name
            if owner:
                if len(name) &gt; len(owner) + 1:
                    sol_name = name[len(owner) + 1 :]
            result.append(
                {
                    &#34;wids&#34;: [c_dict[&#34;wid&#34;]],
                    &#34;Name&#34;: sol_name,
                    &#34;IPv4 Address&#34;: c_dict[&#34;ipv4&#34;],
                    &#34;IPv6 Address&#34;: c_dict[&#34;ipv6&#34;],
                    &#34;Node&#34;: c_dict[&#34;node&#34;],
                    &#34;Farm&#34;: self.get_node_farm(c_dict[&#34;node&#34;]),
                    &#34;Pool&#34;: c_dict[&#34;pool&#34;],
                    &#34;Network&#34;: c_dict[&#34;network&#34;],
                }
            )
            result[-1].update(c_dict[&#34;capacity&#34;])
        return result</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="jumpscale.sals.marketplace.solutions.MarketplaceSolutions" href="../marketplace/solutions.html#jumpscale.sals.marketplace.solutions.MarketplaceSolutions">MarketplaceSolutions</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.cancel_solution"><code class="name flex">
<span>def <span class="ident">cancel_solution</span></span>(<span>self, solution_wids)</span>
</code></dt>
<dd>
<section class="desc"><p>solution_wids should be part of the same solution. if they are not created by the same solution they may not all be deleted</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cancel_solution(self, solution_wids):
    &#34;&#34;&#34;
    solution_wids should be part of the same solution. if they are not created by the same solution they may not all be deleted
    &#34;&#34;&#34;
    workload = j.sals.zos.workloads.get(solution_wids[0])
    solution_uuid = self.get_solution_uuid(workload)
    ids_to_delete = []
    if solution_uuid:
        # solutions created by new chatflows
        for workload in j.sals.zos.workloads.list(j.core.identity.me.tid, next_action=&#34;DEPLOY&#34;):
            if solution_uuid == self.get_solution_uuid(workload):
                ids_to_delete.append(workload.id)
    else:
        ids_to_delete = solution_wids

    for wid in ids_to_delete:
        j.sals.zos.workloads.decomission(wid)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.count_solutions"><code class="name flex">
<span>def <span class="ident">count_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def count_solutions(self, next_action=NextAction.DEPLOY):
    count_dict = {
        &#34;network&#34;: 0,
        &#34;ubuntu&#34;: 0,
        &#34;kubernetes&#34;: 0,
        &#34;minio&#34;: 0,
        &#34;monitoring&#34;: 0,
        &#34;flist&#34;: 0,
        &#34;gitea&#34;: 0,
        &#34;4to6gw&#34;: 0,
        &#34;delegated_domain&#34;: 0,
        &#34;exposed&#34;: 0,
        &#34;threebot&#34;: 0,
        &#34;peertube&#34;: 0,
        &#34;discourse&#34;: 0,
        &#34;gollum&#34;: 0,
        &#34;mattermost&#34;: 0,
        &#34;peertube&#34;: 0,
        &#34;cryptpad&#34;: 0,
        &#34;publisher&#34;: 0,
        &#34;wiki&#34;: 0,
        &#34;blog&#34;: 0,
        &#34;website&#34;: 0,
        &#34;taiga&#34;: 0,
    }
    j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
    for key in count_dict.keys():
        method = getattr(self, f&#34;list_{key}_solutions&#34;)
        count_dict[key] = len(method(next_action=next_action, sync=False))
    return count_dict</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.get_ipv6_address"><code class="name flex">
<span>def <span class="ident">get_ipv6_address</span></span>(<span>self, workload)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_ipv6_address(self, workload):
    result = j.data.serializers.json.loads(workload.info.result.data_json)
    if not result:
        result = {}
    return result.get(&#34;ipv6&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.get_node_farm"><code class="name flex">
<span>def <span class="ident">get_node_farm</span></span>(<span>self, node_id)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_node_farm(self, node_id):
    explorer = j.core.identity.me.explorer
    farm_id = explorer.nodes.get(node_id).farm_id
    return str(explorer.farms.get(farm_id))</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.get_solution_uuid"><code class="name flex">
<span>def <span class="ident">get_solution_uuid</span></span>(<span>self, workload)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_solution_uuid(self, workload):
    if workload.info.metadata:
        try:
            metadata = j.data.serializers.json.loads(
                j.sals.reservation_chatflow.deployer.decrypt_metadata(workload.info.metadata)
            )
        except:
            return
        if metadata:
            solution_uuid = metadata.get(&#34;solution_uuid&#34;)
            return solution_uuid</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.get_workload_capacity"><code class="name flex">
<span>def <span class="ident">get_workload_capacity</span></span>(<span>self, workload)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_workload_capacity(self, workload):
    result = {}
    if workload.info.workload_type == WorkloadType.Container:
        result[&#34;CPU&#34;] = workload.capacity.cpu
        result[&#34;Memory&#34;] = workload.capacity.memory
        result[&#34;RootFS Type&#34;] = workload.capacity.disk_type.name
        result[&#34;RootFS Size&#34;] = workload.capacity.disk_size
    elif workload.info.workload_type == WorkloadType.Kubernetes:
        result.update(K8S_SIZES.get(workload.size, {}))
    elif workload.info.workload_type == WorkloadType.Volume:
        result[&#34;Size&#34;] = workload.size * 1024
        result[&#34;Type&#34;] = workload.type.name
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_4to6gw_solutions"><code class="name flex">
<span>def <span class="ident">list_4to6gw_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_4to6gw_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    if sync:
        j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
    if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Gateway4to6]:
        j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
    result = []
    for gateways in j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Gateway4to6].values():
        for g in gateways:
            result.append(
                {
                    &#34;wids&#34;: [g.id],
                    &#34;Name&#34;: g.public_key,
                    &#34;Public Key&#34;: g.public_key,
                    &#34;Gateway&#34;: g.info.node_id,
                    &#34;Pool&#34;: g.info.pool_id,
                }
            )
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_blog_solutions"><code class="name flex">
<span>def <span class="ident">list_blog_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_blog_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    return self._list_proxied_solution(&#34;blog&#34;, next_action, sync, None)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_cryptpad_solutions"><code class="name flex">
<span>def <span class="ident">list_cryptpad_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_cryptpad_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    return self._list_proxied_solution(&#34;cryptpad&#34;, next_action, sync, &#34;nginx&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_delegated_domain_solutions"><code class="name flex">
<span>def <span class="ident">list_delegated_domain_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_delegated_domain_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    if sync:
        j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
    if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Domain_delegate]:
        j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
    result = []
    for domains in j.sals.reservation_chatflow.deployer.workloads[next_action][
        WorkloadType.Domain_delegate
    ].values():
        for dom in domains:
            result.append(
                {&#34;wids&#34;: [dom.id], &#34;Name&#34;: dom.domain, &#34;Gateway&#34;: dom.info.node_id, &#34;Pool&#34;: dom.info.pool_id}
            )
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_discourse_solutions"><code class="name flex">
<span>def <span class="ident">list_discourse_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_discourse_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    return self._list_proxied_solution(&#34;discourse&#34;, next_action, sync, &#34;nginx&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_exposed_solutions"><code class="name flex">
<span>def <span class="ident">list_exposed_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_exposed_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    if sync:
        j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
    if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Reverse_proxy]:
        j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
    result = {}
    pools = set()
    name_to_proxy = {}
    for proxies in j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Reverse_proxy].values():
        for proxy in proxies:
            if proxy.info.metadata:
                metadata = j.data.serializers.json.loads(proxy.info.metadata)
                if not metadata:
                    continue
                chatflow = metadata.get(&#34;form_info&#34;, {}).get(&#34;chatflow&#34;)
                if chatflow and chatflow != &#34;exposed&#34;:
                    continue
                result[f&#34;{proxy.info.pool_id}-{proxy.domain}&#34;] = {
                    &#34;wids&#34;: [proxy.id],
                    &#34;Name&#34;: proxy.domain,
                    &#34;Gateway&#34;: proxy.info.node_id,
                    &#34;Pool&#34;: proxy.info.pool_id,
                    &#34;Domain&#34;: proxy.domain,
                }
                name = metadata.get(&#34;Solution name&#34;, metadata.get(&#34;form_info&#34;, {}).get(&#34;Solution name&#34;))
                name_to_proxy[name] = f&#34;{proxy.info.pool_id}-{proxy.domain}&#34;
            pools.add(proxy.info.pool_id)

    # link subdomains to proxy_reservations
    for subdomains in j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Subdomain].values():
        for workload in subdomains:
            metadata = j.data.serializers.json.loads(workload.info.metadata)
            if not metadata:
                continue
            chatflow = metadata.get(&#34;form_info&#34;, {}).get(&#34;chatflow&#34;)
            if chatflow and chatflow != &#34;exposed&#34;:
                continue
            solution_name = metadata.get(
                &#34;Solution name&#34;, metadata.get(&#34;name&#34;, metadata.get(&#34;form_info&#34;, {}).get(&#34;Solution name&#34;))
            )
            if not solution_name:
                continue
            domain = workload.domain
            if name_to_proxy.get(solution_name):
                result[name_to_proxy[solution_name]][&#34;wids&#34;].append(workload.id)

    # link tcp router containers to proxy reservations
    for pool_id in pools:
        for container_workload in j.sals.reservation_chatflow.deployer.workloads[next_action][
            WorkloadType.Container
        ][pool_id]:
            if (
                container_workload.flist != &#34;https://hub.grid.tf/tf-official-apps/tcprouter:latest.flist&#34;
                or not container_workload.info.metadata
            ):
                continue
            metadata = j.data.serializers.json.loads(container_workload.info.metadata)
            if not metadata:
                continue
            chatflow = metadata.get(&#34;form_info&#34;, {}).get(&#34;chatflow&#34;)
            if chatflow and chatflow != &#34;exposed&#34;:
                continue
            solution_name = metadata.get(
                &#34;Solution name&#34;, metadata.get(&#34;name&#34;, metadata.get(&#34;form_info&#34;, {}).get(&#34;Solution name&#34;))
            )
            if not solution_name:
                continue
            if name_to_proxy.get(solution_name):
                domain = name_to_proxy.get(solution_name)
                result[domain][&#34;wids&#34;].append(container_workload.id)
    return list(result.values())</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_flist_solutions"><code class="name flex">
<span>def <span class="ident">list_flist_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_flist_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    return self._list_single_container_solution(&#34;flist&#34;, next_action, sync)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_gitea_solutions"><code class="name flex">
<span>def <span class="ident">list_gitea_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_gitea_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    return self._list_proxied_solution(&#34;gitea&#34;, next_action, sync, &#34;nginx&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_gollum_solutions"><code class="name flex">
<span>def <span class="ident">list_gollum_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_gollum_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    return self._list_single_container_solution(&#34;gollum&#34;, next_action, sync)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_kubernetes_solutions"><code class="name flex">
<span>def <span class="ident">list_kubernetes_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_kubernetes_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    if sync:
        j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
    if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Kubernetes]:
        j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
    result = {}
    for kube_workloads in j.sals.reservation_chatflow.deployer.workloads[next_action][
        WorkloadType.Kubernetes
    ].values():
        for workload in kube_workloads:
            if not workload.info.metadata:
                continue
            try:
                metadata = j.data.serializers.json.loads(workload.info.metadata)
            except:
                continue
            if not metadata.get(&#34;form_info&#34;):
                continue
            name = metadata[&#34;form_info&#34;].get(&#34;Solution name&#34;, metadata.get(&#34;name&#34;))
            if name:
                if name in result:
                    if workload.master_ips:
                        result[name][&#34;wids&#34;].append(workload.id)
                        result[name][&#34;Slave IPs&#34;].append(workload.ipaddress)
                        result[name][&#34;Slave Pools&#34;].append(workload.info.pool_id)
                    continue
                result[name] = {
                    &#34;wids&#34;: [workload.id],
                    &#34;Name&#34;: name,
                    &#34;Network&#34;: workload.network_id,
                    &#34;Master IP&#34;: workload.ipaddress if not workload.master_ips else workload.master_ips[0],
                    &#34;Slave IPs&#34;: [],
                    &#34;Slave Pools&#34;: [],
                    &#34;Master Pool&#34;: workload.info.pool_id,
                }
                result[name].update(self.get_workload_capacity(workload))
                if workload.master_ips:
                    result[name][&#34;Slave IPs&#34;].append(workload.ipaddress)
    return list(result.values())</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_mattermost_solutions"><code class="name flex">
<span>def <span class="ident">list_mattermost_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_mattermost_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    return self._list_proxied_solution(&#34;mattermost&#34;, next_action, sync, &#34;nginx&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_minio_solutions"><code class="name flex">
<span>def <span class="ident">list_minio_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_minio_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    if sync:
        j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
    if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Container]:
        j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
    result = []
    container_workloads = self._list_container_workloads(&#34;minio&#34;, next_action)
    for name in container_workloads:
        primary_dict = container_workloads[name][0]
        solution_dict = {
            &#34;wids&#34;: [primary_dict[&#34;wid&#34;]] + primary_dict[&#34;vol_ids&#34;],
            &#34;Name&#34;: name,
            &#34;Network&#34;: primary_dict[&#34;network&#34;],
            &#34;Primary IPv4&#34;: primary_dict[&#34;ipv4&#34;],
            &#34;Primary IPv6&#34;: primary_dict[&#34;ipv6&#34;],
            &#34;Primary Pool&#34;: primary_dict[&#34;pool&#34;],
        }
        for key, val in primary_dict[&#34;capacity&#34;].items():
            solution_dict[f&#34;Primary {key}&#34;] = val
        if len(container_workloads[name]) == 2:
            secondary_dict = container_workloads[name][1]
            solution_dict[&#34;wids&#34;].append(secondary_dict[&#34;wid&#34;])
            solution_dict[&#34;wids&#34;] += secondary_dict[&#34;vol_ids&#34;]
            solution_dict.update(
                {
                    &#34;Secondary IPv4&#34;: secondary_dict[&#34;ipv4&#34;],
                    &#34;Secondary IPv6&#34;: secondary_dict[&#34;ipv6&#34;],
                    &#34;Secondary Pool&#34;: secondary_dict[&#34;pool&#34;],
                }
            )
            for key, val in secondary_dict[&#34;capacity&#34;].items():
                solution_dict[f&#34;Secondary {key}&#34;] = val
        result.append(solution_dict)
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_monitoring_solutions"><code class="name flex">
<span>def <span class="ident">list_monitoring_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_monitoring_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    if sync:
        j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
    if not sync and not j.sals.reservation_chatflow.deployer.workloads[next_action][WorkloadType.Container]:
        j.sals.reservation_chatflow.deployer.load_user_workloads(next_action=next_action)
    result = []
    container_workloads = self._list_container_workloads(&#34;monitoring&#34;, next_action)
    for name in container_workloads:
        if len(container_workloads[name]) != 3:
            continue
        solution_dict = {&#34;wids&#34;: [], &#34;Name&#34;: name}
        for c_dict in container_workloads[name]:
            solution_dict[&#34;wids&#34;].append(c_dict[&#34;wid&#34;])
            solution_dict[&#34;wids&#34;] += c_dict[&#34;vol_ids&#34;]
            if &#34;grafana&#34; in c_dict[&#34;flist&#34;]:
                cont_type = &#34;Grafana&#34;
            elif &#34;prometheus&#34; in c_dict[&#34;flist&#34;]:
                cont_type = &#34;Prometheus&#34;
            elif &#34;redis_zinit&#34; in c_dict[&#34;flist&#34;]:
                cont_type = &#34;Redis&#34;
            else:
                continue
            solution_dict[f&#34;{cont_type} IPv4&#34;] = c_dict[&#34;ipv4&#34;]
            solution_dict[f&#34;{cont_type} IPv6&#34;] = c_dict[&#34;ipv6&#34;]
            solution_dict[f&#34;{cont_type} Node&#34;] = c_dict[&#34;node&#34;]
            solution_dict[f&#34;{cont_type} Farm&#34;] = self.get_node_farm(c_dict[&#34;node&#34;])
            solution_dict[f&#34;{cont_type} Pool&#34;] = c_dict[&#34;pool&#34;]
            for key, val in c_dict[&#34;capacity&#34;].items():
                solution_dict[f&#34;{cont_type} {key}&#34;] = val
        result.append(solution_dict)
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_network_solutions"><code class="name flex">
<span>def <span class="ident">list_network_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_network_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    networks = j.sals.reservation_chatflow.deployer.list_networks(next_action=next_action, sync=sync)
    if not sync and not networks:
        networks = j.sals.reservation_chatflow.deployer.list_networks(next_action=next_action, sync=False)
    result = []
    nodes = {}
    farms = {}
    if networks:
        nodes = {node.node_id: node.farm_id for node in j.sals.zos._explorer.nodes.list()}
        farms = {farm.id: farm.name for farm in j.sals.zos._explorer.farms.list()}
    for n in networks.values():
        if not n.network_workloads:
            continue
        result.append(
            {
                &#34;Name&#34;: n.name,
                &#34;IP Range&#34;: n.network_workloads[-1].network_iprange,
                &#34;nodes&#34;: {
                    res.info.node_id: f&#34;{res.iprange} {farms.get(nodes.get(res.info.node_id))}&#34;
                    for res in n.network_workloads
                },
                &#34;wids&#34;: [res.id for res in n.network_workloads],
            }
        )
    return result</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_peertube_solutions"><code class="name flex">
<span>def <span class="ident">list_peertube_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_peertube_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    return self._list_proxied_solution(&#34;peertube&#34;, next_action, sync, &#34;nginx&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_publisher_solutions"><code class="name flex">
<span>def <span class="ident">list_publisher_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_publisher_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    return self._list_proxied_solution(&#34;publisher&#34;, next_action, sync, None)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_taiga_solutions"><code class="name flex">
<span>def <span class="ident">list_taiga_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_taiga_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    return self._list_proxied_solution(&#34;taiga&#34;, next_action, sync, &#34;nginx&#34;)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_threebot_solutions"><code class="name flex">
<span>def <span class="ident">list_threebot_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_threebot_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    return self._list_proxied_solution(&#34;threebot&#34;, next_action, sync)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_ubuntu_solutions"><code class="name flex">
<span>def <span class="ident">list_ubuntu_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_ubuntu_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    return self._list_single_container_solution(&#34;ubuntu&#34;, next_action, sync)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_website_solutions"><code class="name flex">
<span>def <span class="ident">list_website_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_website_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    return self._list_proxied_solution(&#34;website&#34;, next_action, sync, None)</code></pre>
</details>
</dd>
<dt id="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_wiki_solutions"><code class="name flex">
<span>def <span class="ident">list_wiki_solutions</span></span>(<span>self, next_action=&lt;NextAction.DEPLOY: 3&gt;, sync=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def list_wiki_solutions(self, next_action=NextAction.DEPLOY, sync=True):
    return self._list_proxied_solution(&#34;wiki&#34;, next_action, sync, None)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="jumpscale.sals.reservation_chatflow" href="index.html">jumpscale.sals.reservation_chatflow</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions">ChatflowSolutions</a></code></h4>
<ul class="">
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.cancel_solution" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.cancel_solution">cancel_solution</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.count_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.count_solutions">count_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.get_ipv6_address" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.get_ipv6_address">get_ipv6_address</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.get_node_farm" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.get_node_farm">get_node_farm</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.get_solution_uuid" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.get_solution_uuid">get_solution_uuid</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.get_workload_capacity" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.get_workload_capacity">get_workload_capacity</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_4to6gw_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_4to6gw_solutions">list_4to6gw_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_blog_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_blog_solutions">list_blog_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_cryptpad_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_cryptpad_solutions">list_cryptpad_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_delegated_domain_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_delegated_domain_solutions">list_delegated_domain_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_discourse_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_discourse_solutions">list_discourse_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_exposed_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_exposed_solutions">list_exposed_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_flist_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_flist_solutions">list_flist_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_gitea_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_gitea_solutions">list_gitea_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_gollum_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_gollum_solutions">list_gollum_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_kubernetes_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_kubernetes_solutions">list_kubernetes_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_mattermost_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_mattermost_solutions">list_mattermost_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_minio_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_minio_solutions">list_minio_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_monitoring_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_monitoring_solutions">list_monitoring_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_network_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_network_solutions">list_network_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_peertube_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_peertube_solutions">list_peertube_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_publisher_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_publisher_solutions">list_publisher_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_taiga_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_taiga_solutions">list_taiga_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_threebot_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_threebot_solutions">list_threebot_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_ubuntu_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_ubuntu_solutions">list_ubuntu_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_website_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_website_solutions">list_website_solutions</a></code></li>
<li><code><a title="jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_wiki_solutions" href="#jumpscale.sals.reservation_chatflow.solutions.ChatflowSolutions.list_wiki_solutions">list_wiki_solutions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>