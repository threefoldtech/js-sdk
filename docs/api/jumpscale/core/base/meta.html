<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>jumpscale.core.base.meta API documentation</title>
<meta name="description" content="Meta and Base classes for any class with fields …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>jumpscale.core.base.meta</code></h1>
</header>
<section id="section-intro">
<p>Meta and Base classes for any class with fields.</p>
<p>Contains mainly:</p>
<ul>
<li><code><a title="jumpscale.core.base.meta.BaseMeta" href="#jumpscale.core.base.meta.BaseMeta">BaseMeta</a></code>: A meta class to get a new class with field property descriptors ready</li>
<li><code><a title="jumpscale.core.base.meta.Base" href="#jumpscale.core.base.meta.Base">Base</a></code>: The base class which can be used to get/set current field values</li>
</ul>
<p>To explain what it does, we will illustrate the following examples:</p>
<p>If we have a class called <code>Person</code>, with the following definition:</p>
<pre><code class="language-python">class Person:
    name = fields.String(default=&quot;ahmed&quot;)
</code></pre>
<p>Accessing name from class or instance level will yield the same value, an instance of <code>String</code> field:</p>
<pre><code class="language-python">Person.name  #=&gt; &lt;jumpscale.core.base.fields.String object at 0x7efd89980c18&gt;

p = Person()
p.name  #=&gt; &lt;jumpscale.core.base.fields.String object at 0x7efd89980c18&gt;
</code></pre>
<p>The solution to this problem is using data descriptors (see <a href="https://docs.python.org/3/howto/descriptor.html">https://docs.python.org/3/howto/descriptor.html</a>)</p>
<p>In meta and base implementations, we use property data descriptors, so the following class:</p>
<pre><code class="language-python">class Person(Base):
    name = fields.String(default=&quot;ahmed&quot;)
</code></pre>
<p>Should have different behavior when accessing <code>name</code> from a class or an objects, so, it will be converted by meta class to a class like:</p>
<pre><code>class Person(Base):
    def __init__(self):
        self.__name = &quot;ahmed&quot;

    @property
    def get_name(self):
        return self.__name

    @property
    def set_name(self, value):
        self.__name == value

    name = property(get_name, set_name)
</code></pre>
<p>And accessing <code>name</code> from class and object levels will yield:</p>
<pre><code class="language-python">Person.name  #=&gt; &lt;property object at 0x7efd89a259f8&gt;


p = Person()
p.name  #=&gt; &quot;ahmed&quot;
</code></pre>
<p>Parent relationship is supported too, every instance can have a parent object (which must be a <code><a title="jumpscale.core.base.meta.Base" href="#jumpscale.core.base.meta.Base">Base</a></code> type too)</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Meta and Base classes for any class with fields.

Contains mainly:

- `BaseMeta`: A meta class to get a new class with field property descriptors ready
- `Base`: The base class which can be used to get/set current field values


To explain what it does, we will illustrate the following examples:

If we have a class called `Person`, with the following definition:


```python
class Person:
    name = fields.String(default=&#34;ahmed&#34;)
```

Accessing name from class or instance level will yield the same value, an instance of `String` field:

```python
Person.name  #=&gt; &lt;jumpscale.core.base.fields.String object at 0x7efd89980c18&gt;

p = Person()
p.name  #=&gt; &lt;jumpscale.core.base.fields.String object at 0x7efd89980c18&gt;
```

The solution to this problem is using data descriptors (see https://docs.python.org/3/howto/descriptor.html)

In meta and base implementations, we use property data descriptors, so the following class:

```python
class Person(Base):
    name = fields.String(default=&#34;ahmed&#34;)
```

Should have different behavior when accessing `name` from a class or an objects, so, it will be converted by meta class to a class like:

```
class Person(Base):
    def __init__(self):
        self.__name = &#34;ahmed&#34;

    @property
    def get_name(self):
        return self.__name

    @property
    def set_name(self, value):
        self.__name == value

    name = property(get_name, set_name)
```

And accessing `name` from class and object levels will yield:

```python
Person.name  #=&gt; &lt;property object at 0x7efd89a259f8&gt;


p = Person()
p.name  #=&gt; &#34;ahmed&#34;
```


Parent relationship is supported too, every instance can have a parent object (which must be a `Base` type too)
&#34;&#34;&#34;
from types import SimpleNamespace

from jumpscale.core import events

from . import fields
from .factory import Factory, StoredFactory, DuplicateError
from .events import AttributeUpdateEvent


def get_field_property(name: str, field: fields.Field) -&gt; property:
    &#34;&#34;&#34;
    get a new property descriptor object for a field,
    this property will be used to enable getting/setting the actual value

    as the field only describes the type and other validation/conversion options,
    but do not hold the value itself, the vale will be held in the base instance

    the getter and setter will be called when an object is already created,
    and any field is accessed:

    ```python
    car = Car()
    print(car.color)  #=&gt; getter will be called
    car.color = &#34;red&#34;  #=&gt; setter will be called
    ```

    Args:
        name (str): field name
        field (fields.Field): field instance

    Returns:
        property: property descriptor (object)
    &#34;&#34;&#34;

    def getter(self):
        &#34;&#34;&#34;
        getter method this property

        will call `_get_value`, which would if the value is already defined
        and will get the default value if not

        Returns:
            any: the field value
        &#34;&#34;&#34;
        return self._get_value(name, field)

    def setter(self, value):
        &#34;&#34;&#34;
        a setter method for this property

        will call _set_value, which would do some checks:

        - validation: using field.validate_with_name
        - setting an attribute with inner_name in the base instance

        if it&#39;s set correctly, we will:

        - call `_attr_updated` of `self` with the name of this `field`
        - call `on_update` of the `field` with `self`

        Args:
            value (any): a value to be set for this field

        Raises:
            fields.ValidationError: in case the value is not valid
        &#34;&#34;&#34;
        self._set_value(name, field, value)

        # call _attr_updated and on_update handlers
        self._attr_updated(name, value)
        if field.trigger_updates:
            field.on_update(self, value)

    return property(fget=getter, fset=setter)


class BaseMeta(type):
    &#34;&#34;&#34;
    this class is used to get a new class with all field attributes replaced by property data descriptors.

    this should be used as a metaclass, example:

    ```python
    class ExampleWithFields(metaclass=BaseMeta):
        name = fields.String()
    ```
    &#34;&#34;&#34;

    def __new__(cls, name: str, based: tuple, attrs: dict) -&gt; type:
        &#34;&#34;&#34;
        get a new class with all field attributes replaced by property data descriptors.

        Args:
            name (str): class name
            based (tuple): super class types (classes)
            attrs (dict): current attributes

        Returns:
            type: a new class
        &#34;&#34;&#34;
        # will collect class fields
        cls_fields = {}

        # get all fields from super classes, we have them ordered in `based`
        # make sure not to re-add any field that&#39;s already added
        # otherwise, fields will be resolved disorderly
        for super_cls in based:
            if hasattr(super_cls, &#34;_fields&#34;):
                for key, field in super_cls._fields.items():
                    if key not in attrs:
                        attrs[key] = field

        # now we maintain old attributes, but convert any attribute with
        # fields.Field type to property descriptor (property object)
        # using get_field_property
        new_attrs = {}
        for key in attrs:
            obj = attrs[key]
            if isinstance(obj, fields.Field):
                cls_fields[key] = obj
                new_attrs[key] = get_field_property(key, obj)
            else:
                # keep other attrs
                new_attrs[key] = obj

        new_class = super(BaseMeta, cls).__new__(cls, name, based, new_attrs)
        # set _fields attributes to cls_fields dict, so, we still have access to field objects
        new_class._fields = cls_fields
        return new_class


class Base(SimpleNamespace, metaclass=BaseMeta):
    def __init__(self, parent_=None, instance_name_=None, **values):
        &#34;&#34;&#34;
        base class implementation for any class with fields which supports getting/setting raw data for any instance fields.

        any instance can have an optional name and a parent.

        ```python
        class Person(Base):
            name = fields.String()
            age = fields.Float()

        p = Person(name=&#34;ahmed&#34;, age=&#34;19&#34;)
        print(p.name, p.age)
        ```

        Args:
            parent_ (Base, optional): parent instance. Defaults to None.
            instance_name_ (str, optional): instance name. Defaults to None.
            **values: any given field values to initiate the instance with
        &#34;&#34;&#34;
        self.__parent = parent_
        self.__instance_name = instance_name_

        self._factories = {}

        # now we create factories
        for name, field in self._get_fields().items():
            if isinstance(field, fields.Factory):
                value = field.factory_type(field.type, name_=name, parent_instance_=self)
                self._factories[name] = value
                setattr(self, f&#34;__{name}&#34;, value)
                # if provided in values, remove it, as it&#39;s not needed
                if name in values:
                    values.pop(name)

        # setting other values
        self._set_data(values)

    def _get_fields(self):
        &#34;&#34;&#34;
        get current defined field objects

        Returns:
            dict: fields dict as {name: field object}
        &#34;&#34;&#34;
        return self._fields

    def _get_computed_fields(self):
        &#34;&#34;&#34;
        get current defined field objects with compute function

        Returns:
            dict: fields dict as {name: field object}
        &#34;&#34;&#34;
        return {name: field for name, field in self._fields.items() if field.computed}

    def _get_factories(self):
        &#34;&#34;&#34;
        get sub-factory objects, which are defined by `fields.Factory`

        Returns:
            dict: factories as {name: factory object}
        &#34;&#34;&#34;
        return self._factories

    def _get_embedded_objects(self):
        &#34;&#34;&#34;
        get a list of embedded objects which are defined by `fields.Object`

        Returns:
            list: list of `Base` objects
        &#34;&#34;&#34;
        return [getattr(self, name) for name, field in self._get_fields().items() if isinstance(field, fields.Object)]

    def _get_value(self, name, field):
        &#34;&#34;&#34;
        get a field value

        Args:
            name (str): field name
            field (fields.Field): field object

        Returns:
            any: field value
        &#34;&#34;&#34;
        # if computed, return the computed value
        if field.computed:
            return field.compute(self)

        # if it&#39;s already defined, just return it
        # we don&#39;t use hasattr here, because it uses getattr inside
        # it causes an infinite recursion here if the attr is not found
        # and also when __getattr__ is overridden
        inner_name = f&#34;__{name}&#34;
        if inner_name in self.__dict__:
            return getattr(self, inner_name)

        # if default is callable, get it
        if callable(field.default):
            default = field.default()
        else:
            default = field.default

        # use the actual name (not inner_name) to do validation and conversion...etc
        self._set_value(name, field, default)
        return self._get_value(name, field)

    def _set_value(self, name, field, value):
        &#34;&#34;&#34;
        set a field value

        Args:
            name (str): field name
            field (fields.Field): field object
            value (any): value

        Raises:
            fields.ValidationError: raised if the value is not valid
        &#34;&#34;&#34;
        if field.readonly:
            raise fields.ValidationError(f&#34;&#39;{name}&#39; is a read only attribute&#34;)

        # accept if this is a raw value too
        value = field.from_raw(value)

        # validate
        field.validate_with_name(value, name)

        # set current instance as parent for embedded objects/instances
        if isinstance(field, fields.Object) and value:
            value._set_parent(self)

        # set as an internal attribute
        inner_name = f&#34;__{name}&#34;
        setattr(self, inner_name, value)

    def _get_data(self):
        &#34;&#34;&#34;
        get a serializable dict from all values of all fields (except factories)

        ```python
        class Person(Base):
            name = fields.String()
            age = fields.Float()

        p = Person(name=&#34;ahmed&#34;, age=1.4)
        p._get_data()  #=&gt; {&#39;name&#39;: &#39;ahmed&#39;, &#39;age&#39;: &#39;19&#39;}
        p.to_dict() #=&gt; {&#39;name&#39;: &#39;ahmed&#39;, &#39;age&#39;: &#39;19&#39;}
        ```

        Returns:
            dict: data as dict with {name: value}
        &#34;&#34;&#34;
        data = {}

        for name, field in self._get_fields().items():
            if isinstance(field, fields.Factory):
                # skip for factories for now
                continue
            if not field.stored:
                # skip non-stored fields too
                continue

            value = self._get_value(name, field)
            raw_value = field.to_raw(value)
            if isinstance(field, fields.Secret):
                data[f&#34;__{name}&#34;] = raw_value
            else:
                data[name] = raw_value

        return data

    def _set_data(self, new_data):
        &#34;&#34;&#34;
        set values from dict to all fields (except factories)

        Args:
            new_data (dict): field values mapping
        &#34;&#34;&#34;
        all_fields = self._get_fields()

        for name, value in new_data.items():
            if name in all_fields:
                try:
                    self._set_value(name, all_fields[name], value)
                except (fields.ValidationError, ValueError):
                    # should at least log validation and value errors
                    # this can happen in case of e.g. fields type change
                    pass

    def _attr_updated(self, name, value):
        &#34;&#34;&#34;
        called when an attribute value is updated

        Args:
            name (str): attribute/field name
            value (any): value
        &#34;&#34;&#34;
        event = AttributeUpdateEvent(self, name, value)
        events.notify(event)

    def validate(self):
        &#34;&#34;&#34;
        validate all fields of current instance
        &#34;&#34;&#34;
        for name, field in self._get_fields().items():
            field.validate_with_name(getattr(self, name), name)

    @property
    def parent(self):
        return self.__parent

    def _set_parent(self, parent):
        &#34;&#34;&#34;
        set current parent instance

        Args:
            parent (Base): base object/instance
        &#34;&#34;&#34;
        self.__parent = parent

    @property
    def instance_name(self):
        return self.__instance_name

    def _set_instance_name(self, name):
        &#34;&#34;&#34;
        set current instance name

        Args:
            name (str): name
        &#34;&#34;&#34;
        self.__instance_name = name

    to_dict = _get_data

    @classmethod
    def from_dict(cls, data):
        &#34;&#34;&#34;
        get an instance from a dict

        ```python
        class Person(Base):
            name = fields.String()
            age = fields.Float()

        p = Person.from_dict({&#34;name&#34;: &#34;ahmed&#34;, &#34;age&#34;: 19})
        print(p.name, p.age)  #=&gt; ahmed 19
        ```

        Args:
            data (dict): values dict

        Returns:
            Base: an instance from current `Base` type
        &#34;&#34;&#34;
        return cls(**data)

    def __eq__(self, other):
        &#34;&#34;&#34;
        compare self to `other`, which must be of the same type.

        this just compares the data of two objects.

        Args:
            other (Base): other object of the same type of `self`

        Returns:
            bool: `True` if equal, `False` otherwise
        &#34;&#34;&#34;
        return type(self) == type(other) and self.to_dict() == other.to_dict()

    def __str__(self):
        &#34;&#34;&#34;
        construct a readable string of base objects as  key-value list

        example:

        ```python
        print(j.servers.openresty.tttt.websites.test.locations.l)
        ```

        output:

        ```
        Location(
            instance_name=&#39;l&#39;,
            parent=Website(instance_name_=&#39;test&#39;),
            name=None,
            path_url=&#39;/&#39;,
            is_auth=False,
            force_https=False,
            ...
        )
        ```

        Returns:
            str: readable string
        &#34;&#34;&#34;
        data = {}

        if self.instance_name:
            data[&#34;instance_name&#34;] = self.instance_name.__repr__()

        if self.parent and self.parent.instance_name:
            parent_instance_name = self.parent.instance_name.__repr__()
            data[&#34;parent&#34;] = f&#34;{self.parent.__class__.__name__}(instance_name_={parent_instance_name})&#34;

        for name, field in self._get_fields().items():
            data[name] = self._get_value(name, field).__repr__()

        values = &#34;,\n&#34;.join([f&#34;  {name}={value}&#34; for name, value in data.items()])
        return f&#34;{self.__class__.__name__}(\n{values}\n)&#34;

    __repr__ = __str__</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="jumpscale.core.base.meta.get_field_property"><code class="name flex">
<span>def <span class="ident">get_field_property</span></span>(<span>name: str, field: <a title="jumpscale.core.base.fields.Field" href="fields.html#jumpscale.core.base.fields.Field">Field</a>) ‑> property</span>
</code></dt>
<dd>
<div class="desc"><p>get a new property descriptor object for a field,
this property will be used to enable getting/setting the actual value</p>
<p>as the field only describes the type and other validation/conversion options,
but do not hold the value itself, the vale will be held in the base instance</p>
<p>the getter and setter will be called when an object is already created,
and any field is accessed:</p>
<pre><code class="language-python">car = Car()
print(car.color)  #=&gt; getter will be called
car.color = &quot;red&quot;  #=&gt; setter will be called
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>field name</dd>
<dt><strong><code>field</code></strong> :&ensp;<code>fields.Field</code></dt>
<dd>field instance</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>property</code></dt>
<dd>property descriptor (object)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_field_property(name: str, field: fields.Field) -&gt; property:
    &#34;&#34;&#34;
    get a new property descriptor object for a field,
    this property will be used to enable getting/setting the actual value

    as the field only describes the type and other validation/conversion options,
    but do not hold the value itself, the vale will be held in the base instance

    the getter and setter will be called when an object is already created,
    and any field is accessed:

    ```python
    car = Car()
    print(car.color)  #=&gt; getter will be called
    car.color = &#34;red&#34;  #=&gt; setter will be called
    ```

    Args:
        name (str): field name
        field (fields.Field): field instance

    Returns:
        property: property descriptor (object)
    &#34;&#34;&#34;

    def getter(self):
        &#34;&#34;&#34;
        getter method this property

        will call `_get_value`, which would if the value is already defined
        and will get the default value if not

        Returns:
            any: the field value
        &#34;&#34;&#34;
        return self._get_value(name, field)

    def setter(self, value):
        &#34;&#34;&#34;
        a setter method for this property

        will call _set_value, which would do some checks:

        - validation: using field.validate_with_name
        - setting an attribute with inner_name in the base instance

        if it&#39;s set correctly, we will:

        - call `_attr_updated` of `self` with the name of this `field`
        - call `on_update` of the `field` with `self`

        Args:
            value (any): a value to be set for this field

        Raises:
            fields.ValidationError: in case the value is not valid
        &#34;&#34;&#34;
        self._set_value(name, field, value)

        # call _attr_updated and on_update handlers
        self._attr_updated(name, value)
        if field.trigger_updates:
            field.on_update(self, value)

    return property(fget=getter, fset=setter)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="jumpscale.core.base.meta.Base"><code class="flex name class">
<span>class <span class="ident">Base</span></span>
<span>(</span><span>parent_=None, instance_name_=None, **values)</span>
</code></dt>
<dd>
<div class="desc"><p>A simple attribute-based namespace.</p>
<p>SimpleNamespace(**kwargs)</p>
<p>base class implementation for any class with fields which supports getting/setting raw data for any instance fields.</p>
<p>any instance can have an optional name and a parent.</p>
<pre><code class="language-python">class Person(Base):
    name = fields.String()
    age = fields.Float()

p = Person(name=&quot;ahmed&quot;, age=&quot;19&quot;)
print(p.name, p.age)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_</code></strong> :&ensp;<code><a title="jumpscale.core.base.meta.Base" href="#jumpscale.core.base.meta.Base">Base</a></code>, optional</dt>
<dd>parent instance. Defaults to None.</dd>
<dt><strong><code>instance_name_</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>instance name. Defaults to None.</dd>
<dt><strong><code>**values</code></strong></dt>
<dd>any given field values to initiate the instance with</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Base(SimpleNamespace, metaclass=BaseMeta):
    def __init__(self, parent_=None, instance_name_=None, **values):
        &#34;&#34;&#34;
        base class implementation for any class with fields which supports getting/setting raw data for any instance fields.

        any instance can have an optional name and a parent.

        ```python
        class Person(Base):
            name = fields.String()
            age = fields.Float()

        p = Person(name=&#34;ahmed&#34;, age=&#34;19&#34;)
        print(p.name, p.age)
        ```

        Args:
            parent_ (Base, optional): parent instance. Defaults to None.
            instance_name_ (str, optional): instance name. Defaults to None.
            **values: any given field values to initiate the instance with
        &#34;&#34;&#34;
        self.__parent = parent_
        self.__instance_name = instance_name_

        self._factories = {}

        # now we create factories
        for name, field in self._get_fields().items():
            if isinstance(field, fields.Factory):
                value = field.factory_type(field.type, name_=name, parent_instance_=self)
                self._factories[name] = value
                setattr(self, f&#34;__{name}&#34;, value)
                # if provided in values, remove it, as it&#39;s not needed
                if name in values:
                    values.pop(name)

        # setting other values
        self._set_data(values)

    def _get_fields(self):
        &#34;&#34;&#34;
        get current defined field objects

        Returns:
            dict: fields dict as {name: field object}
        &#34;&#34;&#34;
        return self._fields

    def _get_computed_fields(self):
        &#34;&#34;&#34;
        get current defined field objects with compute function

        Returns:
            dict: fields dict as {name: field object}
        &#34;&#34;&#34;
        return {name: field for name, field in self._fields.items() if field.computed}

    def _get_factories(self):
        &#34;&#34;&#34;
        get sub-factory objects, which are defined by `fields.Factory`

        Returns:
            dict: factories as {name: factory object}
        &#34;&#34;&#34;
        return self._factories

    def _get_embedded_objects(self):
        &#34;&#34;&#34;
        get a list of embedded objects which are defined by `fields.Object`

        Returns:
            list: list of `Base` objects
        &#34;&#34;&#34;
        return [getattr(self, name) for name, field in self._get_fields().items() if isinstance(field, fields.Object)]

    def _get_value(self, name, field):
        &#34;&#34;&#34;
        get a field value

        Args:
            name (str): field name
            field (fields.Field): field object

        Returns:
            any: field value
        &#34;&#34;&#34;
        # if computed, return the computed value
        if field.computed:
            return field.compute(self)

        # if it&#39;s already defined, just return it
        # we don&#39;t use hasattr here, because it uses getattr inside
        # it causes an infinite recursion here if the attr is not found
        # and also when __getattr__ is overridden
        inner_name = f&#34;__{name}&#34;
        if inner_name in self.__dict__:
            return getattr(self, inner_name)

        # if default is callable, get it
        if callable(field.default):
            default = field.default()
        else:
            default = field.default

        # use the actual name (not inner_name) to do validation and conversion...etc
        self._set_value(name, field, default)
        return self._get_value(name, field)

    def _set_value(self, name, field, value):
        &#34;&#34;&#34;
        set a field value

        Args:
            name (str): field name
            field (fields.Field): field object
            value (any): value

        Raises:
            fields.ValidationError: raised if the value is not valid
        &#34;&#34;&#34;
        if field.readonly:
            raise fields.ValidationError(f&#34;&#39;{name}&#39; is a read only attribute&#34;)

        # accept if this is a raw value too
        value = field.from_raw(value)

        # validate
        field.validate_with_name(value, name)

        # set current instance as parent for embedded objects/instances
        if isinstance(field, fields.Object) and value:
            value._set_parent(self)

        # set as an internal attribute
        inner_name = f&#34;__{name}&#34;
        setattr(self, inner_name, value)

    def _get_data(self):
        &#34;&#34;&#34;
        get a serializable dict from all values of all fields (except factories)

        ```python
        class Person(Base):
            name = fields.String()
            age = fields.Float()

        p = Person(name=&#34;ahmed&#34;, age=1.4)
        p._get_data()  #=&gt; {&#39;name&#39;: &#39;ahmed&#39;, &#39;age&#39;: &#39;19&#39;}
        p.to_dict() #=&gt; {&#39;name&#39;: &#39;ahmed&#39;, &#39;age&#39;: &#39;19&#39;}
        ```

        Returns:
            dict: data as dict with {name: value}
        &#34;&#34;&#34;
        data = {}

        for name, field in self._get_fields().items():
            if isinstance(field, fields.Factory):
                # skip for factories for now
                continue
            if not field.stored:
                # skip non-stored fields too
                continue

            value = self._get_value(name, field)
            raw_value = field.to_raw(value)
            if isinstance(field, fields.Secret):
                data[f&#34;__{name}&#34;] = raw_value
            else:
                data[name] = raw_value

        return data

    def _set_data(self, new_data):
        &#34;&#34;&#34;
        set values from dict to all fields (except factories)

        Args:
            new_data (dict): field values mapping
        &#34;&#34;&#34;
        all_fields = self._get_fields()

        for name, value in new_data.items():
            if name in all_fields:
                try:
                    self._set_value(name, all_fields[name], value)
                except (fields.ValidationError, ValueError):
                    # should at least log validation and value errors
                    # this can happen in case of e.g. fields type change
                    pass

    def _attr_updated(self, name, value):
        &#34;&#34;&#34;
        called when an attribute value is updated

        Args:
            name (str): attribute/field name
            value (any): value
        &#34;&#34;&#34;
        event = AttributeUpdateEvent(self, name, value)
        events.notify(event)

    def validate(self):
        &#34;&#34;&#34;
        validate all fields of current instance
        &#34;&#34;&#34;
        for name, field in self._get_fields().items():
            field.validate_with_name(getattr(self, name), name)

    @property
    def parent(self):
        return self.__parent

    def _set_parent(self, parent):
        &#34;&#34;&#34;
        set current parent instance

        Args:
            parent (Base): base object/instance
        &#34;&#34;&#34;
        self.__parent = parent

    @property
    def instance_name(self):
        return self.__instance_name

    def _set_instance_name(self, name):
        &#34;&#34;&#34;
        set current instance name

        Args:
            name (str): name
        &#34;&#34;&#34;
        self.__instance_name = name

    to_dict = _get_data

    @classmethod
    def from_dict(cls, data):
        &#34;&#34;&#34;
        get an instance from a dict

        ```python
        class Person(Base):
            name = fields.String()
            age = fields.Float()

        p = Person.from_dict({&#34;name&#34;: &#34;ahmed&#34;, &#34;age&#34;: 19})
        print(p.name, p.age)  #=&gt; ahmed 19
        ```

        Args:
            data (dict): values dict

        Returns:
            Base: an instance from current `Base` type
        &#34;&#34;&#34;
        return cls(**data)

    def __eq__(self, other):
        &#34;&#34;&#34;
        compare self to `other`, which must be of the same type.

        this just compares the data of two objects.

        Args:
            other (Base): other object of the same type of `self`

        Returns:
            bool: `True` if equal, `False` otherwise
        &#34;&#34;&#34;
        return type(self) == type(other) and self.to_dict() == other.to_dict()

    def __str__(self):
        &#34;&#34;&#34;
        construct a readable string of base objects as  key-value list

        example:

        ```python
        print(j.servers.openresty.tttt.websites.test.locations.l)
        ```

        output:

        ```
        Location(
            instance_name=&#39;l&#39;,
            parent=Website(instance_name_=&#39;test&#39;),
            name=None,
            path_url=&#39;/&#39;,
            is_auth=False,
            force_https=False,
            ...
        )
        ```

        Returns:
            str: readable string
        &#34;&#34;&#34;
        data = {}

        if self.instance_name:
            data[&#34;instance_name&#34;] = self.instance_name.__repr__()

        if self.parent and self.parent.instance_name:
            parent_instance_name = self.parent.instance_name.__repr__()
            data[&#34;parent&#34;] = f&#34;{self.parent.__class__.__name__}(instance_name_={parent_instance_name})&#34;

        for name, field in self._get_fields().items():
            data[name] = self._get_value(name, field).__repr__()

        values = &#34;,\n&#34;.join([f&#34;  {name}={value}&#34; for name, value in data.items()])
        return f&#34;{self.__class__.__name__}(\n{values}\n)&#34;

    __repr__ = __str__</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>types.SimpleNamespace</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="jumpscale.clients.base.Client" href="../../clients/base.html#jumpscale.clients.base.Client">Client</a></li>
<li><a title="jumpscale.clients.github.base.base" href="../../clients/github/base.html#jumpscale.clients.github.base.base">base</a></li>
<li><a title="jumpscale.clients.gogs.gogs.User" href="../../clients/gogs/gogs.html#jumpscale.clients.gogs.gogs.User">User</a></li>
<li><a title="jumpscale.clients.kraken.kraken.Price" href="../../clients/kraken/kraken.html#jumpscale.clients.kraken.kraken.Price">Price</a></li>
<li><a title="jumpscale.clients.liquid.liquid.Price" href="../../clients/liquid/liquid.html#jumpscale.clients.liquid.liquid.Price">Price</a></li>
<li><a title="jumpscale.core.identity.Identity" href="../identity/index.html#jumpscale.core.identity.Identity">Identity</a></li>
<li><a title="jumpscale.packages.admin.bottle.models.UserEntry" href="../../packages/admin/bottle/models.html#jumpscale.packages.admin.bottle.models.UserEntry">UserEntry</a></li>
<li><a title="jumpscale.sals.backupjob.backupjob.BackupJob" href="../../sals/backupjob/backupjob.html#jumpscale.sals.backupjob.backupjob.BackupJob">BackupJob</a></li>
<li><a title="jumpscale.sals.billing.models.Payment" href="../../sals/billing/models.html#jumpscale.sals.billing.models.Payment">Payment</a></li>
<li><a title="jumpscale.sals.billing.models.PaymentResult" href="../../sals/billing/models.html#jumpscale.sals.billing.models.PaymentResult">PaymentResult</a></li>
<li><a title="jumpscale.sals.billing.models.PaymentTransaction" href="../../sals/billing/models.html#jumpscale.sals.billing.models.PaymentTransaction">PaymentTransaction</a></li>
<li><a title="jumpscale.sals.billing.models.PaymentTransactionRefund" href="../../sals/billing/models.html#jumpscale.sals.billing.models.PaymentTransactionRefund">PaymentTransactionRefund</a></li>
<li><a title="jumpscale.sals.billing.models.RefundRequest" href="../../sals/billing/models.html#jumpscale.sals.billing.models.RefundRequest">RefundRequest</a></li>
<li><a title="jumpscale.sals.chatflows.models.voter_model.User" href="../../sals/chatflows/models/voter_model.html#jumpscale.sals.chatflows.models.voter_model.User">User</a></li>
<li><a title="jumpscale.sals.nginx.nginx.Certbot" href="../../sals/nginx/nginx.html#jumpscale.sals.nginx.nginx.Certbot">Certbot</a></li>
<li><a title="jumpscale.sals.nginx.nginx.Location" href="../../sals/nginx/nginx.html#jumpscale.sals.nginx.nginx.Location">Location</a></li>
<li><a title="jumpscale.sals.nginx.nginx.NginxConfig" href="../../sals/nginx/nginx.html#jumpscale.sals.nginx.nginx.NginxConfig">NginxConfig</a></li>
<li><a title="jumpscale.sals.nginx.nginx.Website" href="../../sals/nginx/nginx.html#jumpscale.sals.nginx.nginx.Website">Website</a></li>
<li><a title="jumpscale.servers.gedis.server.GedisServer" href="../../servers/gedis/server.html#jumpscale.servers.gedis.server.GedisServer">GedisServer</a></li>
<li><a title="jumpscale.servers.gedis_http.GedisHTTPServer" href="../../servers/gedis_http/index.html#jumpscale.servers.gedis_http.GedisHTTPServer">GedisHTTPServer</a></li>
<li><a title="jumpscale.servers.openresty.location.Location" href="../../servers/openresty/location.html#jumpscale.servers.openresty.location.Location">Location</a></li>
<li><a title="jumpscale.servers.openresty.server.OpenRestyServer" href="../../servers/openresty/server.html#jumpscale.servers.openresty.server.OpenRestyServer">OpenRestyServer</a></li>
<li><a title="jumpscale.servers.openresty.server.Website" href="../../servers/openresty/server.html#jumpscale.servers.openresty.server.Website">Website</a></li>
<li><a title="jumpscale.servers.rack.rack.ServerRack" href="../../servers/rack/rack.html#jumpscale.servers.rack.rack.ServerRack">ServerRack</a></li>
<li><a title="jumpscale.servers.threebot.threebot.PackageManager" href="../../servers/threebot/threebot.html#jumpscale.servers.threebot.threebot.PackageManager">PackageManager</a></li>
<li><a title="jumpscale.servers.threebot.threebot.ThreebotServer" href="../../servers/threebot/threebot.html#jumpscale.servers.threebot.threebot.ThreebotServer">ThreebotServer</a></li>
<li><a title="jumpscale.tools.nginx.nginxserver.NginxServer" href="../../tools/nginx/nginxserver.html#jumpscale.tools.nginx.nginxserver.NginxServer">NginxServer</a></li>
<li><a title="jumpscale.tools.redis.redis.RedisServer" href="../../tools/redis/redis.html#jumpscale.tools.redis.redis.RedisServer">RedisServer</a></li>
<li><a title="jumpscale.tools.restic.restic.ResticRepo" href="../../tools/restic/restic.html#jumpscale.tools.restic.restic.ResticRepo">ResticRepo</a></li>
<li><a title="jumpscale.tools.servicemanager.servicemanager.ServiceManager" href="../../tools/servicemanager/servicemanager.html#jumpscale.tools.servicemanager.servicemanager.ServiceManager">ServiceManager</a></li>
<li><a title="jumpscale.tools.startupcmd.startupcmd.StartupCmd" href="../../tools/startupcmd/startupcmd.html#jumpscale.tools.startupcmd.startupcmd.StartupCmd">StartupCmd</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="jumpscale.core.base.meta.Base.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>get an instance from a dict</p>
<pre><code class="language-python">class Person(Base):
    name = fields.String()
    age = fields.Float()

p = Person.from_dict({&quot;name&quot;: &quot;ahmed&quot;, &quot;age&quot;: 19})
print(p.name, p.age)  #=&gt; ahmed 19
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>values dict</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="jumpscale.core.base.meta.Base" href="#jumpscale.core.base.meta.Base">Base</a></code></dt>
<dd>an instance from current <code><a title="jumpscale.core.base.meta.Base" href="#jumpscale.core.base.meta.Base">Base</a></code> type</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dict(cls, data):
    &#34;&#34;&#34;
    get an instance from a dict

    ```python
    class Person(Base):
        name = fields.String()
        age = fields.Float()

    p = Person.from_dict({&#34;name&#34;: &#34;ahmed&#34;, &#34;age&#34;: 19})
    print(p.name, p.age)  #=&gt; ahmed 19
    ```

    Args:
        data (dict): values dict

    Returns:
        Base: an instance from current `Base` type
    &#34;&#34;&#34;
    return cls(**data)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="jumpscale.core.base.meta.Base.instance_name"><code class="name">var <span class="ident">instance_name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def instance_name(self):
    return self.__instance_name</code></pre>
</details>
</dd>
<dt id="jumpscale.core.base.meta.Base.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    return self.__parent</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="jumpscale.core.base.meta.Base.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get a serializable dict from all values of all fields (except factories)</p>
<pre><code class="language-python">class Person(Base):
    name = fields.String()
    age = fields.Float()

p = Person(name=&quot;ahmed&quot;, age=1.4)
p._get_data()  #=&gt; {'name': 'ahmed', 'age': '19'}
p.to_dict() #=&gt; {'name': 'ahmed', 'age': '19'}
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>data as dict with {name: value}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _get_data(self):
    &#34;&#34;&#34;
    get a serializable dict from all values of all fields (except factories)

    ```python
    class Person(Base):
        name = fields.String()
        age = fields.Float()

    p = Person(name=&#34;ahmed&#34;, age=1.4)
    p._get_data()  #=&gt; {&#39;name&#39;: &#39;ahmed&#39;, &#39;age&#39;: &#39;19&#39;}
    p.to_dict() #=&gt; {&#39;name&#39;: &#39;ahmed&#39;, &#39;age&#39;: &#39;19&#39;}
    ```

    Returns:
        dict: data as dict with {name: value}
    &#34;&#34;&#34;
    data = {}

    for name, field in self._get_fields().items():
        if isinstance(field, fields.Factory):
            # skip for factories for now
            continue
        if not field.stored:
            # skip non-stored fields too
            continue

        value = self._get_value(name, field)
        raw_value = field.to_raw(value)
        if isinstance(field, fields.Secret):
            data[f&#34;__{name}&#34;] = raw_value
        else:
            data[name] = raw_value

    return data</code></pre>
</details>
</dd>
<dt id="jumpscale.core.base.meta.Base.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>validate all fields of current instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self):
    &#34;&#34;&#34;
    validate all fields of current instance
    &#34;&#34;&#34;
    for name, field in self._get_fields().items():
        field.validate_with_name(getattr(self, name), name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="jumpscale.core.base.meta.BaseMeta"><code class="flex name class">
<span>class <span class="ident">BaseMeta</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>this class is used to get a new class with all field attributes replaced by property data descriptors.</p>
<p>this should be used as a metaclass, example:</p>
<pre><code class="language-python">class ExampleWithFields(metaclass=BaseMeta):
    name = fields.String()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseMeta(type):
    &#34;&#34;&#34;
    this class is used to get a new class with all field attributes replaced by property data descriptors.

    this should be used as a metaclass, example:

    ```python
    class ExampleWithFields(metaclass=BaseMeta):
        name = fields.String()
    ```
    &#34;&#34;&#34;

    def __new__(cls, name: str, based: tuple, attrs: dict) -&gt; type:
        &#34;&#34;&#34;
        get a new class with all field attributes replaced by property data descriptors.

        Args:
            name (str): class name
            based (tuple): super class types (classes)
            attrs (dict): current attributes

        Returns:
            type: a new class
        &#34;&#34;&#34;
        # will collect class fields
        cls_fields = {}

        # get all fields from super classes, we have them ordered in `based`
        # make sure not to re-add any field that&#39;s already added
        # otherwise, fields will be resolved disorderly
        for super_cls in based:
            if hasattr(super_cls, &#34;_fields&#34;):
                for key, field in super_cls._fields.items():
                    if key not in attrs:
                        attrs[key] = field

        # now we maintain old attributes, but convert any attribute with
        # fields.Field type to property descriptor (property object)
        # using get_field_property
        new_attrs = {}
        for key in attrs:
            obj = attrs[key]
            if isinstance(obj, fields.Field):
                cls_fields[key] = obj
                new_attrs[key] = get_field_property(key, obj)
            else:
                # keep other attrs
                new_attrs[key] = obj

        new_class = super(BaseMeta, cls).__new__(cls, name, based, new_attrs)
        # set _fields attributes to cls_fields dict, so, we still have access to field objects
        new_class._fields = cls_fields
        return new_class</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="jumpscale.core.base" href="index.html">jumpscale.core.base</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="jumpscale.core.base.meta.get_field_property" href="#jumpscale.core.base.meta.get_field_property">get_field_property</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="jumpscale.core.base.meta.Base" href="#jumpscale.core.base.meta.Base">Base</a></code></h4>
<ul class="">
<li><code><a title="jumpscale.core.base.meta.Base.from_dict" href="#jumpscale.core.base.meta.Base.from_dict">from_dict</a></code></li>
<li><code><a title="jumpscale.core.base.meta.Base.instance_name" href="#jumpscale.core.base.meta.Base.instance_name">instance_name</a></code></li>
<li><code><a title="jumpscale.core.base.meta.Base.parent" href="#jumpscale.core.base.meta.Base.parent">parent</a></code></li>
<li><code><a title="jumpscale.core.base.meta.Base.to_dict" href="#jumpscale.core.base.meta.Base.to_dict">to_dict</a></code></li>
<li><code><a title="jumpscale.core.base.meta.Base.validate" href="#jumpscale.core.base.meta.Base.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="jumpscale.core.base.meta.BaseMeta" href="#jumpscale.core.base.meta.BaseMeta">BaseMeta</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
